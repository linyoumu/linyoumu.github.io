[{"title":"XCode14 & iOS16 适配问题","date":"2022-07-17T08:49:45.000Z","url":"/17/XCode14-iOS16-%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1、不升级电脑系统与 Xcode，调试iOS 16 1、下载iOS16 Support文件 2、放置到Xcode DeviceSupport目录重启Xcode即可/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 2、iOS16手机开启开发者模式iOS16手机未打开开发者模式时：1、Xcode 无法选中 iOS16的设备，报错：developer mode disable2、无法打开升级前编译的App 解决办法：打开调试手机-设置-隐私与安全-开发者模式-开启开发者模式（需要重启手机） 3、Pod工程中的Bundle target签名报错 方法一：手动选择Pod工程中的Bundle target 签名中的Team，与主工程一致 方法二：在Podfile脚本中设置你的开发者的Team ID 方法三：在Podfile脚本中设置CODE_SIGN_IDENTITY为空来避免报错，这是目前在用的，也是最简单的方法 "},{"title":"objc源码编译","date":"2022-05-26T12:26:49.000Z","url":"/26/objc%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、环境配置 macOS:12.5 Xcode:13.4.1 objc4-841.13 依赖项目 dyld-960 Libc-1507.100.9 libclosure-79.1 libplatform-273.100.5 libpthread-486.100.11 xnu-8020.140.41 所有的源码都可以在opensource中找到，最好找与当前系统匹配的版本下的文件。 二、配置首先选中objc target进行编译。 修改脚本 “macosx.internal” 为 “macosx” ： 并且修改Base Sdk为macOS： 2.&#39;sys/reason.h&#39; file not found在项目根目录创建自己的文件夹，我这里是 LibHeader，将xnu中的bsd/sys目录中的sys/reason.h文件拷贝到这个目录中： 配置Search Header： 以同样的方式处理以下的： 错误 库 目录 &#39;mach-o/dyld_priv.h&#39; file not found dyld include/mach-o &#39;os/lock_private.h&#39; file not found libplatform os/lock_private.h &#39;os/base_private.h&#39; file not found xnu os/base_private.h &#39;pthread/tsd_private.h&#39; file not found libpthread pthread/tsd_private.h &#39;System/machine/cpu_capabilities.h&#39; file not found xnu System/machine/cpu_capabilities.h（osfmk/machine/目录下的） &#39;os/tsd.h&#39; file not found xnu os/tsd.h &#39;pthread/spinlock_private.h&#39; file not found libpthread pthread/spinlock_private.h &#39;System/pthread_machdep.h&#39; file not found libc System/pthread_machdep.hlibc新版本中没有找打，老版本有 &#39;CrashReporterClient.h&#39; file not found libc CrashReporterClient.h&#39;libc新版本中没有找打，老版本有 &#39;os/linker_set.h&#39; file not found Libc os/linker_set.h &#39;Cambria/Traps.h&#39; file not found xnu Cambria/Traps.h &#39;_simple.h&#39; file not found libplatform _simple.h &#39;Cambria/Cambria.h&#39; file not found 注释掉 &#39;kern/restartable.h&#39; file not found xnu kern/restartable.h &#39;os/feature_private.h&#39; file not found 注释 objc-bp-assist.h&#39; file not found 注释 &#39;objc-shared-cache.h&#39; file not found dyld objc-shared-cache.h &#39;os/feature_private.h&#39; file not found 注释 &#39;os/reason_private.h&#39; file not found 注释 &#39;os/variant_private.h&#39; file not found 注释 &#39;Block_private.h&#39; file not found libclourse Block_private.h 还需要增加LIBC_NO_LIBCRASHREPORTERCLIENT宏定义： 3.Expected &#39;,&#39; 注释掉bridgeos相关内容： 4.Use of undeclared identifier &#39;dyld_platform_version_macOS_10_11&#39; 直接注释掉。 5.Use of undeclared identifier &#39;oah_is_current_process_translated&#39; 直接注释 6.Use of undeclared identifier &#39;dyld_fall_2020_os_versions&#39; 注释 7.Use of undeclared identifier &#39;objc4&#39; 注释 8.&#39;_static_assert&#39; declared as an array with a negative size 注释 9.Use of undeclared identifier &#39;dyld_platform_version_macOS_10_13&#39; 注释 10.Use of undeclared identifier &#39;dyld_fall_2018_os_versions&#39; 修改 11.Use of undeclared identifier &#39;dyld_platform_version_bridgeOS_2_0&#39; 注释 12.libobjc.order 路径问题can&#39;t open order file: /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX11.1.sdk/AppleInternal/OrderFiles/libobjc.order library not found for -lCrashReporterClient release 和 debug 都删除。 14.library not found for -loah 删除-loah。 这个时候一般能正常编译通过了。 三、编译调试 新建一个macOS commandLine Target，ObjcTest： 绑定二进制依赖关系 运行进行源码调试 这个时候断点能够进入，就大功告成。 总结：如果自己的Target编译调试遇见问题，尝试以下配置：1: enable hardened runtime -&gt; NO2: build phase -&gt; denpendenice -&gt; objc3: 如果main函数中断点断不住，尝试重新创建自己的Target将main放在Compile Sources最前面。 可以直接下载我编译好的进行调试objc4-841.13 已编译好的源码"},{"title":"git报错#Support for password authentication was removed on August 13,2021","date":"2022-04-08T07:44:38.000Z","url":"/08/git%E6%8A%A5%E9%94%99-Support-for-password-authentication-was-removed-on-August-13-2021/","tags":[["git","/tags/git/"]],"categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"前言 好久没有用github了，今天想将本地的一个项目推送到github上面。但是今天推送代码到github上面的时候，却一直报错！ remote: Support for password authentication was removed on August 13, 2021. remote: Please see  for information on currently recommended modes of authentication. 翻译： remote: Support for password authentication was removed on August 13,2021.远程：对密码身份验证的支持已于 2021 年 8 月 13 日删除。remote: Please see  二、报错解决 打开github仓库主页，点击右侧头像。显示当前下拉框，并点击进入自己的仓库的设置界面 在设置界面左侧，找到红色方框部分，点击进入开发者设置界面 找到红色方框部分，点击进入 点击红色方框，设置 这里的名称我的是：accessToken 作用时间范围，我为了方便设置的是90天功能，因为是自己的项目和自己仓库，所以我都选择了之后点击下面的绿色按钮就可以创建口令了 创建成功之后，会看到 复制红色方框内容，来到git 设置界面 git remote set-url 远程仓库的名称（默认为origin） https:&#x2F;&#x2F;刚刚复制的口令@github.com&#x2F;你的仓库的用户名称&#x2F;仓库名称.git 总结 要紧跟时代的步伐啊，不然到时候自己的项目或者什么出问题了，都不知道什么原因。这里提醒自己要记得定期查看关注自己项目技术的官方消息，以免一些更新我们不知道，导致错误。"},{"title":"iOS-离屏渲染","date":"2022-03-26T06:13:50.000Z","url":"/26/ios-%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1.图像显示原理1.1 图像到屏幕的流程先来看一张图，我们结合这张图来说 首先要明白的一个东西是Render Server 进程，app本身其实并不负责渲染，渲染是有独立的进程负责的，它就是Render Server 。 当我们在代码里设置修改了UI界面的时候，其实它本质是通过Core Animation修改CALayer。在后续的核心动画总结中 我们会说到UIView和CALayer的关系，以及核心动画的设置等等，这个知识点有点多，需要单独详细的总结出来。所以最后按照图片中的流程显示。 首先，有app处理事件(Handle Events),例如：用户点击了一个按钮，它会触发其他的视图的一个动画等 其次，app通过CPU完成对显示内容的计算 例如：视图的创建，视图的布局 图片文本的绘制等。在完成了对显示内容的计算之后，app对图层进行打包，并在下一次Runloop时，将其发送至Render Server 上面我们提到，Render Server负责渲染。Render Server通过执行Open GL、Core Graphics Metal相关程序。 调用GPU GPU在物理层完成了对图像的渲染。 说到这我们就要停一下，我们来看下一个图 上面的流程图 细化了GPU到控制器的这一个过程。GPU 拿到位图后执行顶点着色、图元装配、光栅化、片段着色等，最后将渲染的结果交到了Frame Buffer(帧缓存区当中)然后视频控制器从帧缓存区中拿到要显示的对象，显示到屏幕上图片中的黄色虚线暂时不用管，下面在说垂直同步信号的时候，就明白了。这是从我们代码中设置UI，然后到屏幕的一个过程。 2.2 显示器显示的过程现在从帧缓存中拿到了渲染的视图，又该怎么显示到显示器上面呢？ 先来看一张图 从图中我们也能大致的明白显示的一个过程。 显示器的电子束从屏幕的左上方开始逐行显示，当第一行扫描完之后接着第二行 又是从左到右，就这样一直到屏幕的最下面扫描完成。我们都知道。手机它是有屏幕的刷新次数的。安卓的现在好多是120的，ios是60。1秒刷新60次，当我们扫描完成以后，屏幕刷新，然后视图就会显示出来。 3.UI卡顿 掉帧3.1垂直同步 Vsync + 双缓冲机制 Double Buffering首先我们了解了上面渲染的过程以后，需要考虑遇到一些特别的情况下，该怎么办？在我们代码里写了一个很复杂的UI视图，然后CPU计算布局、GPU渲染，最后放到缓存区。如果在电子束开始扫描新的一帧时，位图还没有渲染好，而是在扫描到屏幕中间时才渲染完成，被放入帧缓冲器中 。那么已扫描的部分就是上一帧的画面，而未扫描的部分就是新一帧的图像，这样是不是就造成了屏幕撕裂了。 但是，在我们平常开发的过程遇到过屏幕撕裂的问题吗？没有吧，这是为什么呢？显然是苹果做了优化操作了。也就是垂直同步 Vsync + 双缓冲机制 Double Buffering。 垂直同步 Vsync垂直同步 Vsync相当于给帧缓存加了锁，还记得上面说到的那个黄色虚线嘛，在我们扫描完一帧以后，就会发出一个垂直同步的信号，通知开始扫描下一帧的图像了。他就像一个位置秩序的，你得给我排队一个一个来，别插队。插队的后果就是屏幕撕裂。双缓冲机制 Double Buffering扫描显示排队进行了，这样在进行下一帧的位图传入的时候，也就意味着我要立刻拿到位图。不能等CPU+GPU计算渲染后再给位图，这样就影响性能。要怎么解决这个问题呢？肯定是 在你快要渲染之前你就要把这些都完成了。你就像排队打针一样，为了节省时间肯定事先都会挽起袖子，到医生那时，直接一针下去了事。扯远了 哈哈。想预先渲染好，就需要另外一个缓存来放下一帧的位图，在它需要扫描的时候，再把渲染好的位图给了帧缓存，帧缓存拿到以后 开始快乐的扫描 显示。一个图解释 3.2 掉帧卡顿垂直同步和双缓存机制完美的解决了屏幕撕裂的问题，但是又引出一个新的问题：掉帧。掉帧是什么意思呢？从网上copy了一份图 其实很好理解，上面我们说了ios的屏幕刷新是60次，那么在一次刷新的过程中，我们CPU+GPU它没有把新渲染的位图放到帧缓存区，这时候是不是还是显示的原来的图像。当下刷新下一帧的时候，拿到了新的位图，这里是不是就丢失了一帧。 卡顿的根本原因：CPU和GPU渲染流水线耗时过长 掉帧我们平常写界面的时候，通过一些开源的库或者自己使用runloop写的库来检测界面卡顿的时候，屏幕刷新率在50以上就很可以了。一般人哪能体验到掉了10帧。你要刷新率是30，那卡顿想过就很明显了。 4 离屏渲染4.1什么是离屏渲染 离屏渲染的过程是指在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作.过程：首先会创建一个当前屏幕缓冲区以外的新缓存区，屏幕渲染会有一个上下文环境，离屏渲染的过程就是切花上下文环境，现充当前屏幕切换到离屏，等结束以后又将上下文切换回来。所以需要更长的时间来处理。时间一长就可能造成掉帧。并且 Offscreen Buffer离屏缓存 本身就需要额外的空间，大量的离屏渲染可能造成内存过大的压力。而且离屏缓存区并不是没有限制大小的，它是不能超过屏幕总像素的2.5倍。 4.2为什么要使用离屏渲染1.一些特殊效果需要使用额外的 Offscreen Buffer 来保存渲染的中间状态，所以不得不使用离屏渲染。2.处于效率目的，可以将内容提前渲染保存在 Offscreen Buffer 中，达到复用的目的。当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前(下一个VSync信号开始前)不能直接在屏幕中绘制，所以就需要屏幕外渲染。 5.触发离屏渲染 为图层设置遮罩(layer.mask) 图层的layer. masksToBounds&#x2F;view.clipsToBounds属性设置为true 将图层layer. allowsGroupOpacity设置为yes和layer. opacity&lt;1.0 为图层设置阴影(layer.shadow) 为图层设置shouldRasterize光栅化6 复杂形状设置圆角等7 渐变8 文本（任何种类，包括UILabel，CATextLayer，Core Text等)9 使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。 5 离屏渲染的优化圆角优化 方法一 方法二利用mask设置圆角，利用贝塞斯曲线和CAShapeLayer来完成 方法三利用CoreGraphics画一个圆形上下文，然后把图片绘制上去 shadows（阴影） 设置阴影后，设置CALayer的shadowPath mask（遮罩） 不使用mask使用混合图层 使用混合图层，在layer上方叠加相应mask形状的半透明layer allowsGroupOpacity（组不透明) 关闭 allowsGroupOpacity 属性，按产品需求自己控制layer透明度 edge antialiasing（抗锯齿） 不设置 allowsEdgeAntialiasing 属性为YES(默认为NO) 当视图内容是静态不变时，设置 shouldRasterize(光栅化)为YES，此方案最为实用方便 如果视图内容是动态变化的，例如cell中的图片，这个时候使用光栅化会增加系统负荷。"},{"title":"FFmpeg常见指令的使用","date":"2021-11-09T11:54:31.000Z","url":"/09/FFmpeg%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["ffmpeg","/tags/ffmpeg/"]],"categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"ffplay ffplay不仅仅是播放器，也可以作为音视频数据图形化分析工具，ffplay也可以看到视频图像的运动估计方向、音视频波形等，同时也是测试ffmpeg的codec引擎、format引擎、filter引擎工具，还可以进行可视化的媒体参数分析，可以通过ffplay –help来查看: 字段 说明 x 强制设置视频显示窗口的宽度 y 视频显示窗口的高度 s 设置视频显示的宽高 fs 强制设置全屏显示 an 屏蔽音频 vn 屏蔽视频 sn 屏蔽字幕 ss 根据设置的秒进行定位拖动 t 设置播放长度 bytes 设置定位拖动的策略，0不可拖动，1为可拖动，-1为自动 nodisp 关闭图形化显示窗口 f 强制使用设置的格式进行解析 window_title 设置窗口的标题 af 设置音频的滤镜 codec 强制使用设置的codec进行解码 autorotate 自动旋转视频 举个例： ffprobeffprobe是ffmpeg中一个查看多媒体文件信息的模块。此模块可以用来查看多媒体文件格式以及编码。ffprobe的命令较多，这里只简单的列举了一些比较常用的命令。 举个例子说明一下： 输出为： ffmpeg 更多指令感兴趣的可以前往 ffmpeg官网 查看"},{"title":"iOS15适配","date":"2021-09-26T05:53:43.000Z","url":"/26/iOS15%E9%80%82%E9%85%8D/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"注意：以下适配内容，必须适配的会以”必须”标出 UITableView Section的header增加默认间距 导航栏异样iOS 15中，导航栏的问题比较明显，调试之后发现是UINavigationBar部分属性的设置在iOS 15上是无效的，查看导航栏特性API，苹果对导航栏的性能做了优化，默认情况下，如果导航栏与视图没有折叠，导航栏的背景透明，如果系统检测到有重叠的话，会变成毛玻璃的效果。 注意⚠️：UINavigationBarAppearance是iOS 13更新的API，iOS 15 navigationBar的相关属性设置要通过实例UINavigationBarAppearance来实现。 在iOS 13 UINavigationBar新增了scrollEdgeAppearance属性，但在iOS 14及更早的版本中此属性只应用在大标题导航栏上。在iOS 15中此属性适用于所有导航栏。 对于scrollEdgeAppearance属性的说明： UITabbartabbar和navigationBar的问题属于同一类，tabbar背景颜色设置失效，字体设置失效，阴影设置失效问题。 注意⚠️：首先是背景色设置失效，需要用UITabBarAppearance来设置 "},{"title":"iOS 开发中的锁","date":"2021-06-02T13:13:34.000Z","url":"/02/iOS-%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"开发中引入了异步和多线程的来提高程序性能，也就意味着线程安全成为了多线程的一个障碍，因此线程锁应运而生，而锁如果用不好，还会造成死锁的风险 下面就介绍ios中常用的几种锁，以及读写锁的实现 常见的多线程锁ios中常见的几种锁包括OSSpinLock、信号量(Semaphore)、pthread_mutex、NSLock、NSCondition、NSConditionLock、pthread_mutex(recursive)、NSRecursiveLock、synchronized 如下所示，为前辈们测试锁性能的案例图(实际可能会略有偏差)： 由于OSSpinLock目前已经不再安全，这里就放弃介绍 我们再选锁的时候，如果只是使用互斥锁的效果，那么按照性能排序选择靠前的即可，如果需要锁的一些其他功能，那么根据需要选择，不必过于局限于性能，毕竟实现功能与项目的维护也是非常重要的 其他锁的使用如下所示 信号量(semaphore)信号量实现加锁功能与其他的略有不同，其通过一个信号值来决定是否阻塞当前线程 wait操作可以使得信号量值减少1，signal使得信号量值增加1 当wait操作使得信号量值小于0时，则所在线程阻塞阻塞休眠，使用signal使得信号量增加时，会顺序唤醒阻塞线程，以此便可以实现加锁功能, pthread互斥锁pthread互斥锁是 pthread 库中的一员，linux系统中中常用的库,使用时需要手动import导入 #import &lt;pthread/pthread.h&gt; 其中有 pthread_mutex_trylock为尝试加锁，如果没被加锁，则会加锁成功，并返回0，适用于一些优先级比较低，间歇性调用的功能 注意：其他部分锁也有trylock这个功能，例如 NSLock、NSRecursiveLock、NSConditionLock NSLock互斥锁NSLock 遵循 NSLocking协议,是常见的互斥锁之一，为 OC 框架中的 API，使用方便，据说是 pthread 封装的锁 tryLock 方法也是尝试加锁，成功返回true，失败返回false lockBeforeDate:(NSDate *)limit 在一个时间之间加锁，可以理解为加锁日期截止到指定时间，会自动解锁(与信号量的等待功能一样，这个是设置到指定时间) NSCondition锁NSCondition 算是一个稍微重量级的锁了，我理解为情景锁(另一个原因区分条件锁 NSConditionLock)，适用于一些特殊场景，其也遵循 NSLocking协议，也属于互斥锁 并且再其基础上，新增了信号量功能 wait和 signal，即 等待 和 释放 ，使用方式和 semaphore 一样，可以通过信号量控制线程的阻塞和释放，除此之外，还多了一个broadcast，其可以解除所有因 wait 阻塞的线程 如下所示，使用 NSCondition 实现了一个生产者和消费者的案例（生产者和消费者都是同一拨人，因此需要加锁来实现，而为了保证有钱了立刻买自己想买的东西，使用信号量，保证没钱时阻塞等待，有钱时立即解放买买买） 其相当于同时使用了NSLock 和 Semaphore 功能 NSConditionLockNSConditionLock 被称为条件锁，其遵循 NSLocking 协议，即具备正常的互斥锁功能 此外加入了 条件语句，为其核心功能，即满足指定条件才会解锁，因此算是一个重量级的锁了，其同时可以理解为 NSCondition 进化版 ，如果你理解了 NSCondition的生产者-消费者模式，这个也会马上就明白了其原理了 lockWhenCondition:(NSInteger)condition: 加锁，当条件condition为传入的condition时，方能解锁 unlockWithCondition:(NSInteger)condition: 更新condition的值，并解锁指定condition的锁 下面使用一个异步队列，来实现类似 NSOperation 设置的依赖关系，如下所示(打印结果1、4、3、2)： 上面的流程可以大致简化为下面几步： 1.创建一个异步队列，以便于添加后续的任务依赖 2.逐步添加子任务模块，分别在不同线程中，其有明确的依赖关系，即执行顺序为 1、4、3、2 3.使用 lockWhenCondition：开始设置依赖，将其任务解锁的条件condition 设置为其特有的condition 号，以便于解锁 4.执行任务时，如果 NSCondition 中的 condition 参数，与本线程设置的tCondition不一样时，阻塞线程，等待 NSCondition 中的 condition 更改为指定值(通过 unlockWithCondition:更改condition值)解锁 即：默认初始化 condition 为 1，只有 任务1 能够执行，当 任务1 执行 unlockWithCondition:4时，condition被设置为4, 阻塞的任务4解锁，同理，任务4执行完毕后，将 condition 设置为 3 ,任务三解锁，依次类推 5.最终根据设置的依赖关系，分别执行 任务1、任务4、任务3、任务2 pthread_mutex(recursive)其为基于 pthread框架 的递归锁，也是以 pthread互斥锁为基础实现的 递归锁，即：同一个线程下，递归调用时加锁，不会阻塞当前线程，当另一个线程到来时，会因为第一个线程加的锁而阻塞 NSRecursiveLock递归锁和 pthread_mutex(recursive)一样，NSRecursiveLock 也是递归锁，其遵循 NSLocking 协议，即除了递归锁功能，还具备正常的互斥锁功能 使用方式和 pthread_mutex(recursive)一样如下所示 synchronizedsynchronized 同步锁，即同步执行，以此避免多线程同时操作同一块代码，基本上在各个平台都会有其身影，虽然效率最低，但由于使用使用简单，深得大家喜爱 实现如下所示 读写锁读写锁 又被称为 rw锁或者 readwrite锁，在 ios开发中虽能见到，但确不是最常用的(一般是数据库操作才会用到)。 具体操作为：多读单写，即，写入操作只能串行执行，且写入时，不能读取，而读取需支持多线程操作，且读取时，不能写入 相信大家也遇到过这样的事，系统的属性设置了 auto参数，字面意思为原子性操作，其实际未能保证属性字段的多线程安全(由于旧值的赋值未加锁，同时写入时，会造成对象旧地址多次被release) 因此无论是想了解其实现方式，还是开发备用，都是有比较学习的 实现方式这里就提供两种：pthread、GCD的barrier来实现 pthread读写锁使用前，需要先导入 pthread框架, 即 #import &lt;pthread/pthread.h&gt; 实现简单，可以根据自己程序需要，选择锁初始化的合适位置 GCD的barrier读写锁GCD的barrier栅栏功能相信大家都听说过，即在一个新创建的队列中，barrier功能可以保证，在他之前的异步队列执行完毕才指定barrier中间的内容，且还能保证barrier执行完毕后，才之后barrier之后的任务，且一个队列可以有多个barrier 因此此特性可以用于完成一个读写锁功能，即 barrier的代码块作为 写入操作模块 如下代码所示，由于需要引入 新创建队列，虽然使用起来不是不如pthread优秀，但这种思想却可以再恰当的时候发芽出新树苗 "},{"title":"SDWebImage源码分析","date":"2021-05-27T12:35:30.000Z","url":"/27/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","tags":[["开源框架","/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、流程架构图 SDWebImage对UIButton，UIImageView，NSButton，UIView进行了拓展，并对外提供了接口。无论对UIButton，UIImageView还是NSButton调用sd_setImageWithURL的时候，最终都会调用到UIView拓展类的sd_internalSetImageWithURL方法。 前面的拓展都只是对外的接口，主要逻辑处理放在SDWebImageManager里面。他相当于一个调度中心，如果需要缓存（读跟取），他就会调用SDImageCache，如果需要下载，就会调用SDWebImageDownloader。类似我们MVP模式下的Presenter，收到View拓展接口相关的参数后，根据不同业务传递给cache跟downloader处理，最后将处理完的数据通过block回调给接口。 最后还有一些工具，没有在流程图中画出来，这里说明一下: Decoder：做一些编解码操作，针对不同类型的图片进行不同的操作。 Transform：从缓存或下载转换图像加载的转换器协议。 AnimatedImage：可以替代UIImageView，支持gif Utils：存放一些枚举，Define，还有菊花器 Categories：对需要的类进行拓展，大部分是UIImage Private：一些私人方法 二、代码部分1. UIView+WebCache 直接找到sd_internalSetImageWithURL方法，这是入口进来后第一个处理的方法，处理内容如下： a. 拿到旧的operation（任务），取消其操作，并从SDOperationsDictionary移除。然后创建新的加载任务，并加入到SDOperationsDictionary中。 b. 处理进度条，重置进度条 c. 处理菊花器 d. 创建SDWebImageManager，并调用loadImageWithURL加载图片 我们先看sd_internalSetImageWithURL方法里面的代码 a、取消之前的任务 这段代码主要是拿到validOperationKey，并传给sd_cancelImage方法，sd_cancelImage的逻辑也很简单，通过validOperationKey，在SDOperationsDictionary里面拿到对应的任务，并取消。下面是sd_cancelImage的代码： b、占位图显示 c、进度条，菊花器处理逻辑 注意这里并没有直接调用combinedProgressBlock处理进度条，而是在下面加载图片的时候将combinedProgressBlock扔过去处理。 d、通过SDWebImageManager调用加载图片的方法这里调用了SDWebImageManager的图片加载方法，将一些必要参数传递过去，接下来就是SDWebImageManager的事情了。 2. SDWebImageManager 直接找到loadImageWithURL方法，这个方法主要是对url的一些判断，context与options的预处理，内容如下： a. 先判断url的可行性 b. 对context，options进行预处理，并放到result里面 c. 调用callCacheProcessForOperation 判断是否有缓存，如果有则进入ImageCache 拿到缓存数据，如果没有则进入callDownloadProcessForOperation 方法进一步判断如何下载 先看看这些步骤的源码，看完再看callCacheProcessForOperation做了些什么 a、判断url的可行性 这里注释应该很清楚了，就是判断url的可行性，跟url是否在失败列表里面，如果在的，且options没有SDWebImageRetryFailed的话，就直接失败回调。值得注意的是SD的锁在iOS10以上用的是os_unfair_lock，iOS10以下用的是OSSpinLockLock（这个锁存在任务优先级问题，已经被淘汰了） b、对context，options进行预处理，并放到result里面 这里先将任务加入到正在执行的列表里面，然后再对context进行预处理，源代码是没有对options进行说明处理的，然后将context跟options放入result里面。context的处理源代码就不贴出来了，大概就是对SDWebImageContextImageTransformer、SDWebImageContextCacheKeyFilter、SDWebImageContextCacheSerializer这3个进行一个判断，看是否有自定义的传过来，没有就用默认的。 c、callCacheProcessForOperation的调用这里主要是判断要到哪里去取数据，ImageCache，还是去下载，接下来就进入这个方法看一下。 这里主要是判断任务是否该走缓存查询，或者直接下载。如果是缓存查询，就进入SDImageCache里面进行缓存查询，且在此处理缓存结果的回调。否则就调用callDownloadProcessForOperation进入下一步判断。 ①. 拿到imageCache，拿到缓存类型queryCacheType ②. 通过 options判断，走缓存还是下载。如果走缓存，则调用SDImageCache里面的queryImageForKey(开始进入SDImageCache的逻辑)；如果走下载，则调用callDownloadProcessForOperation开始下载前的一些处理。 ①、拿到imageCache，拿到缓存类型queryCacheType ②、通过options，判断缓存查找，还是下载 这里解释一下key是怎么拿（SDWebImage的缓存key是怎么样的），逻辑在这个方法里面cacheKeyForURL，代码就不贴出来了，说一下大概逻辑。 a、SDWebImage的context里面有个SDWebImageContextCacheKeyFilter，里面存储的是用来存放自定义key逻辑的协议，通过重写cacheKeyForURL自定义key，如果没有传SDWebImageContextCacheKeyFilter进来则使用url的string值。b、然后通过context里面的SDWebImageContextImageThumbnailPixelSize、SDWebImageContextImagePreserveAspectRatio和SDWebImageContextImageTransformer这3个里面是否有值，如果有值就加上上面的key进行拼接，没值就直接用上面的key。 查到缓存后就是回调了，回调看代码注释，问题应该不大，要注意的是它也走了callDownloadProcessForOperation这个方法，因为options为SDWebImageRefreshCached的情况下，也是要走下载的，所以索性将找到的缓存，放到callDownloadProcessForOperation处理，而不是直接回调。 3.SDImageCache 缓存获取数据，主要是通过key缓存，cacheType判断缓存方式，options进行缓存拓展。主要内容如下： a. 对cacheOptions类型进行筛选 b. 进入queryCacheOperationForKey方法，对具体缓存方式进行划分，其中包括内存缓存，磁盘缓存。然后又在各自缓存下面进行了详细划分 a、内存查找为啥说缓存的查找是先内存呢，看下面这段代码: 一般的queryCacheType默认为SDImageCacheTypeAll，在没有自定义queryCacheType为SDImageCacheTypeDisk的情况下都是先走的memoryCache 而imageFromMemoryCacheForKey这个方法里面的查找方式也很简单，通过封装SDMemoryCache协议，并用NSMapTable&lt;KeyType, ObjectType&gt;类型存储的值去取到对应的image 正常情况下，如果照片找到了，就直接回调block。但是在queryCacheType不指定为SDImageCacheTypeMemory，且options为SDImageCacheQueryMemoryData的时候那就得继续往下，去磁盘查找。 b、磁盘查找磁盘查找分为同步跟异步，默认情况是异步查找，以下情况是同步查找 磁盘的查找有2种方式 一种是通过SDDiskCache协议内部封装的方法，通过key获取path，然后拿到data一种是通过additionalCachePathBlock拿到保存的path，然后拿到data如果是通过磁盘拿到的image，还会将image保存到内存，以便下次查询。 这里说个小细节，磁盘查询的过程是用了@autoreleasepool包了起来，为了防止多张照片查询，引起的内存飙升。 "},{"title":"Block原理","date":"2021-03-27T12:48:41.000Z","url":"/27/Block%E5%8E%9F%E7%90%86/","tags":[["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1.block的类型1.1 全局block 全局block在编译期就被置于macho中的数据段。 在block内部没有使用外部变量，或者只使用的是静态变量或全局变量时，为__NSGlobalBlock__。即使声明的block属性使用了copy修饰也是如此。 1.2 栈block 在MRC下，捕获外界变量时，此block为栈block，但是ARC下系统默认使用__strong修饰且会自动进行copy成堆block。故需要__weak声明. 内部使用了局部变量或者oc属性，但是没有赋值给强引用或者copy修饰的变量，为__NSStackBlock__ 1.3 堆block 在ARC下，捕获了外界变量(不需要__Block和手动调用copy)，就会被拷贝到堆区。 内部使用了局部变量或者oc属性，且赋值给强引用或者copy修饰的变量，为__NSMallocBlock__ 总的来说，block是什么类型，先看它是否使用了外部变量，没使用就是全局block，不管是否强引用；使用了就是栈或者堆，这时候在判断block是否使用了强引用，强引用就是堆，否则就是栈。 1.4 其他的block这三种block是系统提供程序员使用的，实际上还有另外三种block的存在，只是系统自身使用。 libclosure源码中存在如下定义： 总结：一共有6种block，它们都属于NSBlock，只不过只有其中3种是能使用到的2.循环引用block使用不当容易循环引用，导致页面无法被释放。 2.1 循环引用产生 以上两个代码很明显是第一个会产生循环引用。 因为self持有了block，在block内部又持有了self，导致了互相持有。第二段代码不存在互相持有的关系。 要想断开互相持有的关系，必定要有一边弱引用。如果是开头弱引用会造成对象提早被置空的尴尬，那只能是尾部的对象弱引用。 是否循环引用，主要就是看是否能画出互相持有的关系图。比如例子中的：self -&gt; block -&gt; self 2.2 循环引用的解决2.2.1 第一种方式（强弱共舞） 把后面使用的self指向weakSelf，weakSelf是被添加到全局的弱引用表中，不会对引用计数做+1处理,当作用域结束时就会被释放。这样就达到目的了。 但只是这样处理是不保险的，如果在block内部执行的是耗时的方法，那在页面销毁时self就被释放，也就意味着弱应用表中的weakSelf被释放，因为它们是指向同一片内存地址，后续依赖weakSelf的操作自然也就毫无意义了。 正确的做法应该是在block内部在局部强引用下weakSelf，防止这种情况的发生。 因为这样操作后，在页面销毁时，self相当于还是被强持有，不会调用dealloc释放self，只有当2秒延时执行后，block内部的作用域结束，局部变量strongSelf是在栈空间，被系统回收，强持有结束，才会调用dealloc释放self。 所以最终正确的做法，应该是外部__weak修饰一下，内部在用__strong修饰一下。 2.2.2 第二种方式（手动置空） 既然系统在weakSelf作用域结束时会自动置空，那也可以仿造此行为: 局部强应用self，在不需要时手动将其置空。 2.2.3 第三种方式（参数形式） 前两种方法是持有已经形成，采用对尾部的对象弱引用的思想。而参数形式的方法是直接不让self被block持有，自然就没循环引用的可能了。 2.3 哪些页面有循环引用实际开发中，页面没有及时释放，多半就是因为发生了循环引用。 这里提供一种检查页面是否释放的方式，在基类的dealloc方法中打印，打印的内容可以夸张些(表情符号之类)，易于识别。 当发现哪个页面pop之后却没有打印信息，就找找这个控制器中哪里存在循环引用吧。 总结：推荐使用的处理方式 手动置空的方式依赖于程序员的调用，如果忘记调用就存在循环引用，明显这是不可取的 参数形式很优雅，但是可能会导致block过重，可以使用 推荐使用第一种强弱共舞的方式，把对象生命周期交给系统管理是最可靠的，如果觉得写那两句代码很烦，可以用宏简化下 3.Block的clang分析block的本质是什么，为什么能自动捕获变量，为什么需要调用等问题是我们关心的，这一切都需要看看block的底层结构。 block语法看起来好像很特别，其实它实际上是被做为普通的c语言源代码处理的。通过clang可以把block语法的源代码转化为c++源代码。虽说是c++源代码，但底层也是struct结构体，本质上还是c的源代码。 转换如下： 如果头文件有用到系统库，需要指定下路径： 编写一个极为简单的block.c文件， 转换后得到block.cpp，截取其中重要内容并简化后得到： 1.block的本质是什么block被转化为__main_block_impl_0类型的结构体，内部还有__block_impl类型的结构体和__main_block_desc_0类型的结构体做为属性。 所以block的本质就是个结构体，是个对象，这也是为什么它能被%@打印的原因。 2.block为什么能捕获自动变量看__main_block_impl_0内部的结构和main函数源代码。 block在使用自动变量时，把自动变量textA声明为自身__main_block_impl_0结构体内的一个属性，并在__main_block_impl_0构造函数传入textA将其赋值，所以能捕获自动变量。 3.block为什么需要调用看block的实现函数，__main_block_impl_0内部的构造函数。 block的实现在底层被隐式的声明为__main_block_func_0函数，入参是__main_block_impl_0 类型的__cself，也就是自身。 __main_block_impl_0构造函数中，把__main_block_func_0当做入参，保存在__block_impl结构体内的FuncPtr属性。 所以需要外界调用block，也就是调用被保存的在自身的FuncPtr。 4.block为什么不能直接修改自动变量 在使用自动变量时，把结构体内部的textA值以__cself-&gt;textA形式赋值给新声明的textA中，再对这个新声明的textA做操作。 如果直接修改自动变量，相当于修改的是新声明的这个textA，可外界希望修改的是原textA，显然这毫无意义，且会产生代码歧义，编译器不知道你要修改哪个textA，产生报错。 5.__block为什么能修改自动变量增加__block修饰后，继续使用clang转换成新的.cpp文件。 转换后的代码增加了不少，和原先最主要的区别在于： textA被声明成__Block_byref_textA_0类型的结构体，不再是单纯的int 新增了__main_block_copy_0和__main_block_dispose_0函数，它们分别调用了_Block_object_assign和_Block_object_dispose(这两个函数后续分析) 在调用函数(图片写成结构体了)__main_block_func_0时，textA是使用__cself-&gt;textA方式获取到的被保存在__main_block_impl_0结构体内的textA指针。也就是原先传入的textA的，后续对textA的操作，就是对外界textA的操作。所以使用__block修饰后的自动变量可以被修改。 使用__block后，会生产__Block_byref类型的结构体，并且在结构体内部保存了指向自身的__forwarding指针，外界修改时，就是通过指针获取原自动变量进行修改 6.栈block何时拷贝到堆区可以看到，__main_block_impl_0构造函数内的block的isa被定义为_NSConcreteStackBlock，可是在第一节block的类型中说明ARC捕获自动变量后为_NSConcreteMallocBlock。 那么可以肯定的是，一定是存在某种操作，使block产生从栈到堆的改变。 在block汇编源码中的第一次跳转objc_retainBlock时，打个断点，然后读取下x0寄存器的值 证实此时的确是个_NSConcreteStackBlock，单步执行跟进去， 发现又跳转到_Block_copy这个函数，这个关键函数记住，后续还要分析。 在libObjc源码中搜索，也能确认objc_retainBlock就是调用了_Block_copy。 进到_Block_copy的汇编，在最后准备return的地方打上断点，再次读取x0寄存器的值 证实在调用_Block_copy前，block还是_NSConcreteStackBlock，调用之后变成了_NSConcreteMallocBlock。 block在构造函数初始化阶段确实是_NSConcreteStackBlock类型，只不过因为是ARC（未使用__block时），在合适的时机，系统会自动做拷贝到堆的操作，导致结果打印的类型却是_NSConcreteMallocBlock。 这里两次都读取x0寄存器的原因是不同的。第一次是因为做为函数的第一个参数，block被存放在x0寄存器；第二次是因为block做为返回值被存放在x0寄存器。 有以下的情况栈上的block都会被拷贝到堆上： 调用block的copy实例方法时 block做为函数返回值返回时 将block赋值给带有__strong修饰符id类型的类或block类型成员变量时 在方法名中带有usingBlock的系统方法时 使用GCD的API传递的block 不过这些情况都是因为调用了_Block_copy函数。 需要注意的是：并非所有的block执行了_Block_copy都会变成堆block，比如全局block就不行。只有当是栈block时，这些情况才能成立。 7.block的签名是什么在block的打印信息中可以看到： 其中，v代表返回值是void，8代表8字节，而@？就代表block类型。 可以使用代码验证下： 打印信息证明@?是isBlock，也是isObject。 总结： block本质是个结构体，是个对象 block内部使用自动变量时，会把自动变量声明为自身结构体的属性，产生捕获的功能 block的实现被保存在自身结构体中,需要外界调用 不能直接修改自动变量是因为：block内部会生成新的变量，这个变量和捕获的自动变量不是同一个(指向的地址不同，只是值相同)， 而使用__block修饰后，会生成相应的结构体，保存原始变量的指针，修改的就是原始的变量 调用_Block_copy后，栈block被拷贝到堆区，在堆区生成对应的block(必须是栈) 有趣的冷门小知识：我们常说，block是带有自动变量的匿名函数。 但经过clang的分析，发现在.cpp底层中block其实也是有函数名称的，匿名是指外界不需要声明函数名。 并且它的名称有一定的规律： block在函数中时格式为： __函数名_block_impl_此block是函数中的第几个block 比如：__main_block_impl_0 block在方法中时格式为： __文件名_方法名_block_impl_此block是方法中的第几个block 比如：__ViewController__addblcok__block_impl_0 4.block的底层原理经过clang分析后，能大概明白block在底层是以什么样的方式存在的，但是它还不能说明一些东西。 比如：_Block_copy做了什么，__block是怎么实现的，_Block_object_assign和_Block_object_dispose又是什么。 这一切只能打开block的源码libclosure探索了。 这源码还是比较好理解的，内容也较少，推荐阅读 一共只有四个文件，且只需要关注Block_private.h和runtime.cpp这两个文件即可。 Block_private.h：主要是block相关的结构体声明和枚举值的定义 runtime.cpp:具体的实现 试想： block的结构体在.cpp中命名是动态的，可真实的底层结构体命名不可能是动态的，一定有个与之匹配固定的结构体名称。 来到Block_private.h寻找，果然存在和.cpp中相同的结构体，只是名称不同。 4.1 block的结构体Block_layoutblock真实的结构体如下： isa：block的类型指向，类似对象中的isa flags：标志位。且因为flags影响block的诸多操作，需要谨慎读取。所以使用volatile关键字以确保本条指令不会因编译器的优化而省略，且要求每次直接读值 reserved：系统保留字段，暂不使用 invoke：保存block的实现部分 Block_descriptor_1：block的大小信息，必有的 Block_descriptor_2：block是否有copy和dispose函数，可选的 Block_descriptor_3：block的签名和拓展，可选的 4.2 _Block_copy分析之前分析发现Block_copy是个重要函数，现在来跟进分析下。 内部只是根据标志位flags做对应的操作 ② BLOCK_IS_GLOBAL 如果是GLOBALBLOCK直接返回，这证明了调用Block_copy时，并不是都会被拷贝到堆上 ③ // Its a stack block. Make a copy. 系统给出的注释，说明处理栈block。 调用malloc在堆上开辟空间，大小就是传入block的大小，把原block内存上的数据全部复制到新开辟的block上，然后设置新block的一些属性，最后把isa置为_NSConcreteMallocBlock。其中了调用_Block_call_copy_helper会做拷贝成员变量的工作，并且内部调用_Block_object_assign ① BLOCK_NEEDS_FREE 不确定此标志位的意思，但是反推下。已经有栈block和全局block的处理了，那它肯定包含堆block的处理。 只是对block的引用计数做处理。 _Block_copy所做的事，以下表格基本可以说明： block的类型 原blcok存储域 复制效果 _NSConcreteStackBlock 栈 从栈复制到堆 _NSConcreteGlobalBlock 数据区 什么也不做 _NSConcreteMallocBlock 堆 引用计数增加 4.3 _Block_object_assign分析用__block修饰一个对象，然后重新生成.cpp。 发现__block会生成的对应结构体 而源码中也给出了Block_byref的结构体 isa：可能是结构体的类型，但是源码中赋值总是NULL forwarding:自身指向的指针 flags：标志位 size：大小 byref_keep：__Block_byref_id_object_copy_131函数，也就是_Block_object_assign byref_destroy：__Block_byref_id_object_dispose_131函数，也就是_Block_object_dispose __block对应结构体的构造函数 搜索构造函数中的第五个参数， 发现直接调用了_Block_object_assign函数。 来到源码， 第一句是重点代码，但很容易被忽略： block捕获变量时，使用二级指针指向真正的目标指针，这是block能使用__weak解决循环引用的关键所在。 不同的flags代表传入的是不同类型： BLOCK_FIELD_IS_OBJECT： 表示是一个对象 BLOCK_FIELD_IS_BLOCK ：表示是一个block BLOCK_FIELD_IS_BYREF ：表示是一个byref，一个被__block修饰的变量 BLOCK_FIELD_IS_WEAK：__block 变量还被 __weak 修饰时 ① 如果是对象类型，调用_Block_retain_object 可是_Block_retain_object是个空实现，其实就是直接以指针的形式赋值*dest = object 这是因为，对象的引用计数是由ARC管理的，不需要block插手,只要通过指针获取即可。 ② 如果是block类型，调用_Block_copy（已分析） ③ 如果是被__block修饰，调用_Block_byref_copy（新函数，下面分析） ④和⑤ 如果是其他类型，也是直接指针赋值即可。 大概可以看得出来，_Block_object_assign函数是根据捕获自动变量的类型做对应的内存管理。 至于为什么入参是硬编码+40， 从__block生成的结构体可以略知一二， 捕获的自动变量在结构体的偏移值为40字节，+40即可得到此自动变量。 4.3.1 捕获的变量类型当用__weak修饰变量时： 当用__strong修饰变量时： block捕获变量时还有一个特点：遇到强引用捕获的就是强引用，遇到弱引用捕获的就是弱引用。意味着在block结构体内声明的属性类型和修饰符与捕获的变量一致。而这会导致block捕获变量后引用计数产生区别。 4.4 _Block_byref_copy分析当使用__block修饰，会调用_Block_byref_copy函数。 ① 新生成一个Block_byref类型的结构体，并赋初始值，其中这两句代码至关重要 堆上的结构体的forwarding指向自身，栈上的结构体的forwarding指向堆上 通过该功能，无论是在block语法中，还是block语法外使用__block变量，还是__block变量配置在栈上还是堆上，都可以顺利访问到同一个__block变量。 这也就说明了，为什么使用__block修饰的变量具有修改能力。 ② 如果结构体的标志位为BLOCK_BYREF_HAS_COPY_DISPOSE，则向Block_byref结构体的byref_keep和byref_destroy赋值（也就是copy和DISPOSE函数），然后调用 其实也就是调用_Block_object_assign，对捕获的变量的内存进行操作。 ③ 如果__block结构体本身已在堆上，直接对引用计数操作即可。 4.5 _Block_object_dispose分析copy函数和dispose函数是堆block生命周期的开始和结束，他们对应的调用时机： 函数 调用时机 copy函数 栈上的block复制到堆时 dispose函数 堆上的block被废弃时 按释放顺序依次说明： ③ 调用_Block_release_object释放捕获的自动变量，不过其也是个空实现，变量的释放也是ARC管理的 ① 调用_Block_byref_release减少引用计数 通过结构体内部指向自身的forwarding指针找到自身（如果byref已经被拷贝，则取得是堆上的byref，否则是栈上的，栈上的不需要 release，也没有引用计数），如果是堆则减少引用计数，如果引用计数减到了0调用free释放(因为如果之前已经在堆上调用_Block_byref_copy只是引用计数加1，调用_Block_byref_release时也要一次一次减1)。 ② 调用_Block_release减少引用计数 2.1 block在堆上，才需要release，在全局区和栈区直接返回. 2.2 引用计数减1，如果引用计数减到了0，调用free释放block 类似于拷贝时的一层层拷贝，释放也是一层层释放。 总结：block从栈复制到堆上时，先复制自身到堆，在堆上生成对应的__block结构体(如果有使用__block)，在拷贝捕获的自动变量。 这个过程相当于三层拷贝对应三个函数，block自身拷贝（_Block_copy函数），__block拷贝（_Block_byref_copy函数），自动变量拷贝（_Block_object_assign函数） 而释放过程亦是如此。_Block_release_object处理捕获的自动变量，_Block_byref_release处理__block对应的结构体，__Block_release处理block自身。 写在后面block的面试题，首先需要判断block的类型，因为作用域对它的影响是很大的，然后搞清楚不同作用域的block生命周期和block的函数处理，以及捕获变量时是啥捕啥的原理。"},{"title":"iOS底层-类的加载","date":"2021-01-10T07:47:05.000Z","url":"/10/iOS%E5%BA%95%E5%B1%82-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/","tags":[["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"在分析dyld和objc关联的时候，发现_read_images方法中有读取类的方法也有实现类的方法，这篇文章主要讲一下类的加载。_read_images中源码如下： readClass:读取类readClass主要是读取类，在未调用该方法前，cls只是一个地址，执行该方法后，cls是类的名称，其源码实现如下，关键代码是addNamedClass和addClassTableEntry，源码实现如下： 为了能进入到我们自定义的类中，我在源码的基础上了加了部分代码。可以概括为以下几步： 通过mangledName获取类的名字，其中mangledName方法的源码实现如下： 通过addNamedClass将当前类添加到已经创建好的gdb_objc_realized_classes哈希表，该表用于存放所有类： 通过addClassTableEntry，将初始化的类添加到allocatedClasses表，这个表在iOS底层-dyld和objc的关联文章中提及过，是在_objc_init中的runtime_init就创建了allocatedClasses表: 总结 所以综上所述，readClass的主要作用就是将Mach-O中的类读取到内存，即插入表中，但是目前的类仅有两个信息：地址以及名称，而mach-O的其中的data数据还未读取出来。 realizeClassWithoutSwift：实现类realizeClassWithoutSwift方法中有ro、rw的相关操作，这个方法在消息流程的慢速查找中有所提及,方法路径为：慢速查找(lookUpImpOrForward) – realizeClassMaybeSwiftAndLeaveLocked – realizeClassMaybeSwiftMaybeRelock – realizeClassWithoutSwift（实现类） realizeClassWithoutSwift方法主要作用是实现类，将类的data数据加载到内存中，主要有以下几部分操作： 第一步：读取data数据，并设置ro、rw第二步：递归调用realizeClassWithoutSwift完善继承链第三步：通过methodizeClass方法化类 第一步：读取data数据读取class的data数据，并将其强转为ro，以及rw初始化和ro拷贝一份到rw中的ro ro 表示 readOnly，即只读，其在编译时就已经确定了内存，包含类名称、方法、协议和实例变量的信息，由于是只读的，所以属于Clean Memory，而Clean Memory是指加载后不会发生更改的内存 rw 表示 readWrite，即可读可写，由于其动态性，可能会往类中添加属性、方法、添加协议，在最新的2020的WWDC的对内存优化的说明Advancements in the Objective-C runtime - WWDC 2020 - Videos - Apple Developer中，提到rw，其实在rw中只有10%的类真正的更改了它们的方法，所以有了rwe，即类的额外信息。对于那些确实需要额外信息的类，可以分配rwe扩展记录中的一个，并将其滑入类中供其使用。其中rw就属于dirty memory，而 dirty memory是指在进程运行时会发生更改的内存，类结构一经使用就会变成 ditry memory，因为运行时会向它写入新数据，例如 创建一个新的方法缓存，并从类中指向它 第二步：递归调用 realizeClassWithoutSwift 完善 继承链 递归调用realizeClassWithoutSwift完善继承链,并设置当前类、父类、元类的rw 递归调用 realizeClassWithoutSwift设置父类、元类 设置父类和元类的isa指向 通过addSubclass 和 addRootClass设置父子的双向链表指向关系，即父类中可以找到子类，子类中可以找到父类 这里有一个问题，realizeClassWithoutSwift递归调用时，isa找到根元类之后，根元类的isa是指向自己，并不会返回nil，所以有以下递归终止条件，其目的是保证类只加载一次 在realizeClassWithoutSwift中如果类不存在，则返回nil 如果类已经实现，则直接返回cls 第三步：通过 methodizeClass 方法化类 通过methodizeClass方法，从ro中读取方法列表（包括分类中的方法）、属性列表、协议列表赋值给rw，并返回cls 方法如何排序 进入prepareMethodLists的源码实现,其内部是通过fixupMethodList方法排序： 进入fixupMethodList源码实现，是根据selector address排序 通过attachToClass将分类添加到主类中，其源码实现如下： 在attachCategories 方法中准备分类的数据，其源码实现如下: attachLists 是如何插入数据的呢？方法属性协议都可以直接通过 attachLists 插入吗？ 从 attachLists 的源码实现中可以得出: （多对多）如果当前调用 attachLists 的 list_array_tt 二维数组中有多个一维数组 通过 realloc 对容器进行重新分配大小为原来的大小加上新增的大小通过 memmove 把原来的数据移动到容器的末尾把新的数据 memcpy 拷贝到容器的起始位置（0对一）如果调用 attachLists 的 list_array_tt 二维数组为空且新增大小数目为 1 直接赋值 addedList 的第一个 list （一对多）如果当前调用 attachLists 的 list_array_tt 二维数组只有一个一维数组 通过 realloc 对容器进行重新分配大小为原来的大小加上新增的大小由于只有一个一维数组，所以直接赋值到新 Array 的最后一个位置把新的数据 memcpy 拷贝到容器的起始位置而 memmove 和 memcpy 的区别在于： 在不知道需要平移的内存大小时，需要memmove进行内存平移，保证安全memcpy从原内存地址的起始位置开始拷贝若干个字节到目标内存地址中，速度快 其他一、主类实现 load 方法， 其中一个分类实现 load 方法，一个没有实现 load 方法 只要有一个分类是 非懒加载分类， 所有都会是非懒加载分类 二、主类实现 load 方法， 分类没有实现 load 方法主类实现 load 方法，分类的方法来自于主类的 data() -&gt; (const class_ro_t *)cls-&gt;data()，编译时期完成 data() 图2 三、主类没有实现 load 方法， 分类没有实现 load 方法 第一次消息的时候，分类的方法也会来自于主类的 data() -&gt; (const class_ro_t *)cls-&gt;data()，编译时期完成 data() 四、主类没有实现 load 方法， 分类实现 load 方法 迫使类成为非懒加载类样式来提前加载数据 "},{"title":"iOS底层-dyld和objc的关联","date":"2021-01-06T13:51:00.000Z","url":"/06/iOS%E5%BA%95%E5%B1%82-dyld%E5%92%8Cobjc%E7%9A%84%E5%85%B3%E8%81%94/","tags":[["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"objc4-781官方源码_objc_init方法如下： 参数说明 environ_init() : 读取影响运⾏时的环境变量。如果需要，还可以打印环境变量帮助。我们可以点击进入环境变量初始化 environ_init 方法，将控制环境变量打印信息的条件都屏蔽掉，代码如下所示： 控制台打印日志如下： 我们设置打印所有加载的文件的相关的load方法，设置环境 OBJC_PRINT_LOAD_METHODS &#x3D; YES然后再次打印，控制台日志如下: tls_init() 关于线程key的绑定 - ⽐如每线程数据的析构函数 static_init() 运⾏C ++静态构造函数。在dyld调⽤我们的静态构造函数之前，libc 会调⽤ _objc_init（），因此我们必须⾃⼰做 lock_init(): 没有重写,采⽤C++ 的特性 exception_init () 初始化libobjc的异常处理系统 cache_init() 缓存条件初始化 runtime_init() : runtime运⾏时环境初始化,⾥⾯主要是:unattachedCategories,allocatedClasses 后⾯会分析 _imp_implementationWithBlock_init :启动回调机制。通常这不会做什么，因为所有的初始化都是惰性的，但是对于某些进程，我们会迫不及待地加载trampolines dylib。_dyld_objc_notify_register 这个方法是跨库执行的，在苹果开源的 dyld 源码里面可以找到，然后看到调用了 dyld::registerObjCNotifiers 这个方法： load_images 接下来我们分析一下 registerObjCNotifiers 方法的第二个参数 init，（也就是_dyld_objc_notify_register 方法中的 load_images 参数）方法里面有sNotifyObjCInit &#x3D; init; 这个赋值语句，接下来我们在 dyld 源码中全局搜索一下 sNotifyObjCInit ，会发现在 notifySingle 方法中有 sNotifyObjCInit 的调用： 所以在 ObjC 中 _objc_init 方法里调用的 _dyld_objc_notify_register 方法终于在 dyld 源码中找到其真正调用的地方，终于找到了它们真正的关联关系了。 map_images 那么 _dyld_objc_notify_register 方法中的 map_images 参数呢？接下来我们继续找 registerObjCNotifiers 方法中的 sNotifyObjCMapped &#x3D; mapped; 这一赋值语句，在 dyld 源码中全局搜索一下 sNotifyObjCMapped ，同样会发现在 notifyBatchPartial 方法中有 sNotifyObjCMapped 的调用： 所以说 ObjC 中 _objc_init 方法的调用时离不开 dyld 的，它们之间有着紧密的联系。 我们还可以继续探索一下 map_images， 进入到 objc_781 源码，全局搜索相关的函数调用 map_images ，我们能进入相关的函数调用过程： 再进入到 map_images_nolock 方法中，我们能发现其中有很多加载相关类的信息 _read_images： 我们知道，map_images 这个函数的主要功能就是为了映射相关的类信息，所以此处才是我们研究的重点，接着进入到相关的类方法的定义 _read_images 方法，顺着源码分析我们能得到很多关于类的信息： 1.条件控制进⾏⼀次的加载2.修复预编译阶段的 @selector 的混乱问题3.错误混乱的类处理4.修复重映射⼀些没有被镜像⽂件加载进来的 类5.修复⼀些消息!6.当我们类⾥⾯有协议的时候 : readProtocol7.修复没有被加载的协议8.分类处理9.类的加载处理10.没有被处理的类 优化那些被侵犯的类"},{"title":"iOS AVFoundation动态人脸识别功能","date":"2020-12-15T12:21:20.000Z","url":"/15/iOS-AVFoundation%E5%8A%A8%E6%80%81%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E5%8A%9F%E8%83%BD/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、AVCaptureSession:设备输入数据管理对象 可以根据AVCaptureSession创建对应的AVCaptureDeviceInput、AVCaptureVideoDataOutput对象 创建出来的Input、Output对象会被添加到AVCaptureSession中管理，代表输入、输出数据对象，它配置抽象硬件设备的ports。 二、AVCaptureDevice：代表硬件设备 可以从这个类中获取手机硬件的照相机、声音传感器等 当我们在应用程序中需要改变一些硬件设备的属性（切换摄像头、闪光模式改变、相机聚焦改变）的时候必须要先为设备加锁，修改完成后解锁。 三、AVCaptureDeviceInput设备输入数据管理对象 可以根据AVCaptureDevice创建对应的AVCaptureDeviceInput对象 该对象将会被添加到AVCaptureSession中管理，代表输入设备，它配置抽象硬件设备的ports，常用的有麦克风、相机等 四、AVCaptureOutput输出数据 输出的可以是图片(AVCaptureStillImageOutput)或者视频(AVCaptureMovieFileOutput) 五、添加输入、输出数据对象到session中 六、AVCaptureVideoPreviewLayer创建实时预览图层 我们手机的照片以及视频是怎样显示在手机屏幕上的呢，就是通过把这个对象添加到UIView的layer上的。 人脸检测器 检测人脸照片 代理方法 获取到outputSampleBuffer 后进行人脸识别操作。 "},{"title":"iOS-KVO 底层原理","date":"2020-11-01T12:28:51.000Z","url":"/01/iOS-KVO-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","tags":[["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"什么是KVOKVO，全称为Key-Value observing，中文名为键值观察，KVO是一种机制，它允许将其他对象的指定属性的更改通知给对象。在Key-Value Observing Programming Guide官方文档中，又这么一句话：理解KVO之前，必须先理解KVC（即KVO是基于KVC基础之上） In order to understand key-value observing, you must first understand key-value coding.KVC是键值编码，在对象创建完成后，可以动态的给对象属性赋值，而KVO是键值观察，提供了一种监听机制，当指定的对象的属性被修改后，则对象会收到通知，所以可以看出KVO是基于KVC的基础上对属性动态变化的监听 在iOS日常开发中，经常使用KVO来监听对象属性的变化，并及时做出响应，即当指定的被观察的对象的属性被修改后，KVO会自动通知相应的观察者，那么KVO与NSNotificatioCenter有什么区别呢？ 相同点1、两者的实现原理都是观察者模式，都是用于监听2、都能实现一对多的操作 不同点1、KVO只能用于监听对象属性的变化，并且属性名都是通过NSString来查找，编译器不会帮你检测对错和补全,纯手敲会比较容易出错2、NSNotification的发送监听（post）的操作我们可以控制，kvo由系统控制。3、KVO可以记录新旧值变化 KVO使用注意事项1.基本使用KVO的基本使用主要分为3步：1、注册观察者addObserver:forKeyPath:options:context 2、实现KVO回调observeValueForKeyPath:ofObject:change:context 3、移除观察者removeObserver:forKeyPath:context 2、context使用在官方文档中，针对参数context有如下说明： 大致含义就是：addObserver：forKeyPath：options：context：方法中的上下文context指针包含任意数据，这些数据将在相应的更改通知中传递回观察者。可以通过指定context为NULL，从而依靠keyPath即键路径字符串传来确定更改通知的来源，但是这种方法可能会导致对象的父类由于不同的原因也观察到相同的键路径而导致问题。所以可以为每个观察到的keyPath创建一个不同的context，从而完全不需要进行字符串比较，从而可以更有效地进行通知解析 通俗的讲，context上下文主要是用于区分不同对象的同名属性，从而在KVO回调方法中可以直接使用context进行区分，可以大大提升性能，以及代码的可读性 context使用总结 不使用context，使用keyPath区分通知来源 使用context区分通知来源 3.移除KVO通知的必要性在官方文档中，针对KVO的移除有以下几点说明 删除观察者时，请记住以下几点： 要求被移除为观察者（如果尚未注册为观察者）会导致NSRangeException。您可以对removeObserver：forKeyPath：context：进行一次调用，以对应对addObserver：forKeyPath：options：context：的调用，或者，如果在您的应用中不可行，则将removeObserver：forKeyPath：context：调用在try &#x2F; catch块内处理潜在的异常。 释放后，观察者不会自动将其自身移除。被观察对象继续发送通知，而忽略了观察者的状态。但是，与发送到已释放对象的任何其他消息一样，更改通知会触发内存访问异常。因此，您可以确保观察者在从内存中消失之前将自己删除。 该协议无法询问对象是观察者还是被观察者。构造代码以避免发布相关的错误。一种典型的模式是在观察者初始化期间（例如，在init或viewDidLoad中）注册为观察者，并在释放过程中（通常在dealloc中）注销，以确保成对和有序地添加和删除消息，并确保观察者在注册之前被取消注册，从内存中释放出来。 所以，总的来说，KVO注册观察者 和移除观察者是需要成对出现的，如果只注册，不移除，会出现类似野指针的崩溃，如下图所示: 崩溃的原因是，由于第一次注册KVO观察者后没有移除，再次进入界面，会导致第二次注册KVO观察者，导致KVO观察的重复注册，而且第一次的通知对象还在内存中，没有进行释放，此时接收到属性值变化的通知，会出现找不到原有的通知对象，只能找到现有的通知对象，即第二次KVO注册的观察者，所以导致了类似野指针的崩溃，即一直保持着一个野通知，且一直在监听 4、KVO的自动触发与手动触发KVO观察的开启和关闭有两种方式，自动和手动自动开关，返回NO，就监听不到，返回YES，表示监听 自动开关关闭的时候，可以通过手动开关监听 使用手动开关的好处就是你想监听就监听，不想监听关闭即可，比自动触发更方便灵活 5、KVO观察：一对多KVO观察中的一对多，意思是通过注册一个KVO观察者，可以监听多个属性的变化 以下载进度为例，比如目前有一个需求，需要根据总的下载量totalData 和当前下载量currentData 来计算当前的下载进度currentProcess，实现有两种方式 分别观察 总的下载量totalData 和当前下载量currentData 两个属性，当其中一个发生变化计算 当前下载进度currentProcess 实现keyPathsForValuesAffectingValueForKey方法，将两个观察合为一个观察，即观察当前下载进度currentProcess 6、KVO观察 可变数组KVO是基于KVC基础之上的，所以可变数组如果直接添加数据，是不会调用setter方法的，所有对可变数组的KVO观察下面这种方式不生效的,即直接通过[self.person.dateArray addObject:@&quot;1&quot;];向数组添加元素，是不会触发kvo通知回调的 在KVC官方文档中，针对可变数组的集合类型，有如下说明，即访问集合对象需要需要通过mutableArrayValueForKey方法，这样才能将元素添加到可变数组中 将4中的代码修改如下 运行结果如下，可以看到，元素被添加到可变数组了 其中的kind表示键值变化的类型，是一个枚举，主要有以下4种 一般的属性与集合的KVO观察是有区别的，其kind不同，以属性name 和 可变数组为例 属性的kind一般是设值可变数组的kind一般是插入 KVO 底层原理探索官方文档说明 在KVO的官方使用指南中，有如下说明 KVO是使用isa-swizzling的技术实现的。 顾名思义，isa指针指向维护分配表的对象的类。该分派表实质上包含指向该类实现的方法的指针以及其他数据。 当为对象的属性注册观察者时，将修改观察对象的isa指针，指向中间类而不是真实类。结果，isa指针的值不一定反映实例的实际类。 您永远不应依靠isa指针来确定类成员身份。相反，您应该使用class方法来确定对象实例的类。 代码调试探索1、KVO只对属性观察 在LGPerson中有一个成员变量name 和 属性nickName，分别注册KVO观察，触发属性变化时，会有什么现象？ 分别为成员变量name 和 属性nickName注册KVO观察 KVO通知触发操作 运行结果如下: 结论：KVO对成员变量不观察，只对属性观察，属性和成员变量的区别在于属性多一个 setter 方法，而KVO恰好观察的是setter 方法 2、中间类 根据官方文档所述，在注册KVO观察者后，观察对象的isa指针指向会发生改变注册观察者之前：实例对象person的isa指针指向LGPerson 注册观察者之后：实例对象person的isa指针指向NSKVONotifying_LGPerson 综上所述，在注册观察者后，实例对象的isa指针指向由LGPerson类变为了NSKVONotifying_LGPerson中间类，即实例对象的isa指针指向发生了变化 2-1、判断中间类是否是派生类 即子类？ 那么这个动态生成的中间类NSKVONotifying_LGPerson和LGPerson类 有什么关系？下面通过代码来验证 可以通过下面封装的方法，获取LGPerson的相关类 打印结果如下所示: 从结果中可以说明NSKVONotifying_LGPerson是LGPerson的子类 2-2、中间类中有什么？ 可以通过下面的方法获取NSKVONotifying_LGPerson类中的所有方法 输出结果如下 从结果中可以看出有四个方法，分别是setNickName 、 class 、 dealloc 、 _isKVOA，这些方法是继承还是重写？ 在LGStudent中重写setNickName方法，获取LGStudent类的所有方法 与中间类的方法进行的对比说明只有重写的方法，才会在子类的方法列表中遍历打印出来，而继承的不会在子类遍历出来 获取LGPerson和NSKVONotifying_LGPerson的方法列表进行对比 综上所述，有如下结论： NSKVONotifying_LGPerson中间类重写了父类LGPerson的setNickName方法NSKVONotifying_LGPerson中间类重写了基类NSObject的class 、 dealloc 、 _isKVOA方法其中dealloc是释放方法_isKVOA判断当前是否是kvo类2-3、dealloc中移除观察者后，isa指向是谁，以及中间类是否会销毁？ 移除观察者之前：实例对象的isa指向仍是NSKVONotifying_LGPerson中间类 移除观察者之后：实例对象的isa指向更改为LGPerson类 所以，在移除kvo观察者后，isa的指向由NSKVONotifying_LGPerson变成了LGPerson 那么中间类从创建后，到dealloc方法中移除观察者之后，是否还存在？ 在上一级界面打印LGPerson的子类情况，用于判断中间类是否销毁 通过子类的打印结果可以看出，中间类一旦生成，没有移除，没有销毁，还在内存中 – 主要是考虑重用的想法，即中间类注册到内存中，为了考虑后续的重用问题，所以中间类一直存在 总结 综上所述，关于中间类，有如下说明： 实例对象isa的指向在注册KVO观察者之后，由原有类更改为指向中间类 中间类重写了观察属性的setter方法、class、dealloc、_isKVOA方法 dealloc方法中，移除KVO观察者之后，实例对象isa指向由中间类更改为原有类 中间类从创建后，就一直存在内存中，不会被销毁 自定义KVO自定KVO的流程，跟系统一致，只是在系统的基础上针对其中的部分做了一些优化处理。 1、将注册和响应通过函数式编程，即block的方法结合在一起2、去掉系统繁琐的三部曲，实现KVO自动销毁机制在系统中，注册观察者和KVO响应属于响应式编程，是分开写的，在自定义为了代码更好的协调，使用block的形式，将注册和回调的逻辑组合在一起，即采用函数式编程方式，还是分为三部分 注册观察者 KVO响应这部分主要是通过重写setter方法，在中间类的setter方法中，通过block的方式传递给外部进行响应 移除观察者 准备条件：创建NSObject类的分类CJLJVO 注册观察者 在注册观察者方法中，主要有以下几部分操作： 1、判断当前观察值keyPath的setter方法是否存在 2、动态生成子类，将需要重写的class方法添加到中间类中 3、isa指向由原有类，改为指向中间类 4、保存信息：这里用的数组，也可以使用map，需要创建信息的model模型类 完整的注册观察者代码如下 注意点 关于objc_msgSend的检查关闭：target -&gt; Build Setting -&gt; Enable Strict Checking of objc_msgSend Calls 设置为NO class方法必须重写，其目的是为了与系统一样，对外的类保持一致，如下所示系统的KVO，在添加观察者前后，实例对象person的类一直都是CJLPerson 如果没有重写class方法，自定的KVO在注册前后的实例对象person的class就会看到是不一致的,返回的isa更改后的类，即中间类 自定义KVO-未重写class方法的注册前后对比 重写后class方法后的自定义KVO，在注册观察者前后其实例对象类的显示，与系统的显示是一致的 KVO响应 主要是给子类动态添加setter方法，其目的是为了在setter方法中向父类发送消息，告知其属性值的变化 5、将setter方法重写添加到子类中（主要是在注册观察者方法中添加） 6、通过将系统的objc_msgSendSuper强制类型转换自定义的消息发送cjl_msgSendSuper 7、告知vc去响应：获取信息，通过block传递 完整的setter方法代码如下 移除观察者 为了避免在外界不断的调用removeObserver方法，在自定义KVO中实现自动移除观察者 8、实现cjl_removeObserver:forKeyPath:方法，主要是清空数组，以及isa指向更改 9、在子类中重写dealloc方法，当子类销毁时，会自动调用dealloc方法（在动态生成子类的方法中添加） 其原理主要是：CJLPerson发送消息释放即dealloc了，就会自动走到重写的cjl_dealloc方法中（原因是因为person对象的isa指向变了，指向中间类，但是实例对象的地址是不变的，所以子类的释放，相当于释放了外界的person，而重写的cjl_dealloc相当于是重写了CJLPerson的dealloc方法，所以会走到cjl_dealloc方法中），达到自动移除观察者的目的 总结综上所述，自定义KVO大致分为以下几步 注册观察者 &amp; 响应1、验证是否存在setter方法 2、保存信息 3、动态生成子类，需要重写class、setter方法 4、在子类的setter方法中向父类发消息，即自定义消息发送 5、让观察者响应 移除观察者 1、更改isa指向为原有类 2、重写子类的dealloc方法 "},{"title":"iOS-KVC 底层原理","date":"2020-10-27T01:50:29.000Z","url":"/27/iOS-KVC-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","tags":[["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"KVC的全称是Key-Value Coding，翻译成中文是 键值编码，键值编码是由NSKeyValueCoding非正式协议启用的一种机制，对象采用该协议来间接访问其属性。既可以通过一个字符串key来访问某个属性。这种间接访问机制补充了实例变量及其相关的访问器方法所提供的直接访问。 KVC 相关API常用方法 主要有以下四个常用的方法 通过key 设值&#x2F;取值 通过keyPath （即路由）设值&#x2F;取值 其他方法 KVC 设值 底层原理在日常开发中，针对对象属性的赋值，一般有以下两种方式 直接通过setter方法赋值 通过KVC键值编码的相关API赋值 下面针对使用最多的KVC设值方法：setValue:forKey，来进行其底层原理的探索。 首先进入setValue:forKey的声明，发现是在Foundation框架中，而Foundation框架是不开源的，有以下几种方式可以去探索底层 通过Hopper反汇编，查看伪代码 通过苹果官方文档 Github搜索是否有相关的demo 在这里，我们通过Key-Value Coding Programming Guide苹果官方文档来研究，针对设值流程，有如下说明 当调用setValue:forKey:设置属性value时，其底层的执行流程为 【第一步】首先查找是否有这三种setter方法，按照查找顺序为set&lt;Key&gt;：-&gt; _set&lt;Key&gt; -&gt; setIs&lt;Key&gt; 如果有其中任意一个setter方法，则直接设置属性的value（主注意：key是指成员变量名，首字符大小写需要符合KVC的命名规范） 如果都没有，则进入【第二步】 【第二步】：如果没有第一步中的三个简单的setter方法，则查找accessInstanceVariablesDirectly是否返回YES， 如果返回 ，则查找间接访问的实例变量进行赋值，查找顺序为： 如果找到其中任意一个实例变量，则赋值 如果都没有，则进入【第三步】 如果返回NO，则进入【第三步】 【第三步】如果setter方法 或者 实例变量都没有找到，系统会执行该对象的setValue：forUndefinedKey:方法，默认抛出NSUndefinedKeyException类型的异常 综上所述，KVC通过 setValue:forKey: 方法设值的流程以设置LGPerson的对象person的属性name为例，如下图所示 KVC 取值 底层原理同样的，我们可以通过官方文档分析KVC取值的底层原理 当调用valueForKey：时，其底层的执行流程如下 【第一步】首先查找getter方法，按照 的方法顺序查找， 如果找到，则进入【第五步】 如果没有找到，则进入【第二步】 【第二步】如果第一步中的getter方法没有找到，KVC会查找 如果找到countOf &lt;Key&gt;和其他两个中的一个，则会创建一个响应所有NSArray方法的集合代理对象，并返回该对象，即NSKeyValueArray，是NSArray的子类。代理对象随后将接收到的所有NSArray消息转换为countOf&lt;Key&gt;，objectIn&lt;Key&gt; AtIndex：和&lt;key&gt;AtIndexes：消息的某种组合，用来创建键值编码对象。如果原始对象还实现了一个名为get&lt;Key&gt;：range：之类的可选方法，则代理对象也将在适当时使用该方法（注意：方法名的命名规则要符合KVC的标准命名方法，包括方法签名。） 如果没有找到这三个访问数组的，请继续进入【第三步】 【第三步】如果没有找到上面的几种方法，则会同时查找 这三个方法 如果这三个方法都找到，则会创建一个响应所有NSSet方法的集合代理对象，并返回该对象，此代理对象随后将其收到的所有NSSet消息转换为countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;和memberOf&lt;Key&gt;：消息的某种组合，用于创建它的对象 如果还是没有找到，则进入【第四步】 【第四步】如果还没有找到，检查类方法 是否 ，依次搜索 的实例变量 如果搜到，直接获取实例变量的值，进入【第五步】 【第五步】根据搜索到的 ，返回不同的结果 如果是对象指针，则直接返回结果 如果是NSNumber支持的标量类型，则将其存储在NSNumber实例中并返回它 如果是是NSNumber不支持的标量类型，请转换为NSValue对象并返回该对象 【第六步】如果上面5步的方法均失败，系统会执行该对象的valueForUndefinedKey:方法，默认抛出NSUndefinedKeyException类型的异常 综上所述，KVC通过 valueForKey： 方法取值的流程以设置LGPerson的对象person的属性name为例，如下图所示 自定义KVC原理：通过给NSObject添加分类CJLKVC，实现自定义的cjl_setValue:forKey:和cjl_valueForKey:方法，根据苹果官方文档提供的查找规则进行实现 自定义KVC设值自定义KVC设置流程，主要分为以下几个步骤： 1、判断key非空 2、查找setter方法，顺序是：setXXX、_setXXX、 setIsXXX 3、判断是否响应 方法，即间接访问实例变量， 返回YES，继续下一步设值， 如果是NO，则崩溃 4、间接访问变量赋值（只会走一次），顺序是： 4.1 定义一个收集实例变量的可变数组 4.2 通过class_getInstanceVariable方法，获取相应的 ivar 4.3 通过object_setIvar方法，对相应的 ivar 设置值 5、如果找不到相关实例变量，则抛出异常 自定义KVC取值取值的自定义代码如下，分为以下几步 1、判断key非空 2、查找相应方法，顺序是：get&lt;Key&gt;、 &lt;key&gt;、 countOf&lt;Key&gt;、 objectIn&lt;Key&gt;AtIndex 3、判断是否能够直接赋值实例变量，即判断是否响应accessInstanceVariablesDirectly方法，间接访问实例变量， 返回YES，继续下一步取值 如果是NO，则崩溃 4、间接访问实例变量，顺序是：_&lt;key&gt; _is&lt;Key&gt; &lt;key&gt; is&lt;Key&gt; 4.1 定义一个收集实例变量的可变数组 4.2 通过class_getInstanceVariable方法，获取相应的 ivar 4.3 通过object_getIvar方法，返回相应的 ivar 的值 使用路由访问，即keyPath在日常开发中，一个类的成员变量有可能是自定义类或者其他的复杂数据类型，一般的操作是，我们可以先通过KVC获取该属性，然后再通过KVC获取自定义类的属性，就是比较麻烦，还有另一种比较简便的方法，就是使用KeyPath即路由，涉及以下两个方法：setValue:forKeyPath: 和 valueForKeyPath: 参考如下的案例 KVC 使用场景1、动态设值和取值 常用的可以通过setValue:forKey: 和 valueForKey: 也可以通过路由的方式setValue:forKeyPath: 和 valueForKeyPath: 2、通过KVC访问和修改私有变量 在日常开发中，对于类的私有属性，在外部定义的对象，是无法直接访问私有属性的，但是对于KVC而言，一个对象没有自己的隐私，所以可以通过KVC修改和访问任何私有属性 3、多值操作（model和字典互转） model和字典的转换可以通过下面两个KVC的API实现 4、修改一些系统空间的内部属性 在日常开发中，我们知道，很多UI控件都是在其内部由多个UI空间组合而成，这些内部控件苹果并没有提供访问的API，但是使用KVC可以解决这个问题，常用的就是自定义tabbar、个性化UITextField中的placeHolderText 5、用KVC实现高阶消息传递 在对容器类使用KVC时，valueForKey:将会被传递给容器中的每一个对象，而不是对容器本身进行操作，结果会被添加到返回的容器中，这样，可以很方便的操作集合 来返回 另一个集合 如下所示 "},{"title":"Masonry原理解析","date":"2020-09-27T03:19:01.000Z","url":"/27/Masonry%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","tags":[["开源框架","/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"Masonry应该是目前使用最为广泛的对于AutoLayout的封装（Swift版本叫做SnapKit），但是大家对于Masonry的使用只是停留在基础的方式，很少人会去理解Masonry内部去调用AutoLayout的具体原理，致使在UI上容易产生很多的冲突，导致Masonry的Crash等等情况；所以这篇文章主要是来解决上面提出的问题； 关于AutoLayout要讲Masonry必须从iOS的布局历史开始，系统的UI布局大致分为3类： Frame Layout Auto Resizing Auto Layout 所谓FrameLayout即通过设置view的frame属性值从而控制view的位置以及大小； Auto Resizing其实也是属于FrameLayout的范畴，目的就是为了让子view可以跟随superview进行大小的调整；但是不足点就是Auto Resizing无法处理同级间的view布局以及无法让superview根据子view进行反向的数据调整； 于是就出现了Autolayout，它是一种基于约束的布局系统；简单来说Autolayout的本质其实就是解析一组多元一次方程，当要确定一个视图的位置，也是需要确定视图的横纵坐标以及宽度和高度的，只是这个横纵坐标和宽度高度不再是写死的数值，而是根据约束计算得来，从而达到自动布局的效果； 约束的本质就是两个view的线性关系，上图就是一个基本的关系方程式RedView的位置其实是通过BlueView的位置来固定的；这里不做过多的讲解有兴趣的朋友可以去看官方文档 AutoLayout的使用官方对于AutoLayout的使用提供了3种方法；但是其中两种本质都是其实都是使用NSLayoutConstraint对象进行约束； 使用xib以及storyboard进行布局，不过这种方式基本不用，因为不好用； 使用VFL语法进行约束，VFL简直就是一种又臭又长的语法，非常不好用也很难记，需要扫盲的同学可以查看官方文档，我就不多讲了，因为我自己也不是很懂； 使用NSLayoutConstraint纯代码添加，这种方式的缺点就是会大大的增加代码量，平均一个约束就需要写大量的代码，造成开发的效率大大降低； 上面曾经说过三种Autolayout的布局方法有两种的本质是一样的，就是因为VFL的本质其实就是返回多个NSLayoutConstraint对象，而不需要直接一个一个的创建NSLayoutConstraint对象大量减少代码量；个人认为要不是VFL的语法太过于变态，如果简单好用也就没有Masonry什么事了； Masonry的本质其实就是通过链式的语法将一个一个约束关系记录下来，然后通过创建一个一个NSLayoutConstraint对象进行布局约束，Masonry内部的本质其实这样并不复杂，只是存在很多细节点，导致直接使用的它的人会存在许多疑惑点，约束间的关系理不清； 关于Masonry中的宏定义以下有两段代码，其中一个使用了mas_定义另一个没有使用mas_定义，我想绝大部分人在使用的过程中肯定会充满疑惑，好像不管使用哪一个都没有问题； 其实上述两种布局最后的效果都是一样的；原因就是非mas_定义的本质调用还是调用mas_定义的声明； 对于makeConstraints（updateConstraints &amp;&amp; remakeConstraints）三个函数来说，本质还是调用了mas_makeConstraints（mas_updateConstraints &amp;&amp; mas_remakeConstraints）； 对于leading这些属性来说，leading的调用实际调用的还是mas_leading; 我们可以发现对于equalTo函数默认接受的应该是一个NSObject的对象，但是我们却可以传入一个CGSize以及CGFloat这类参数，原因就是因为存在一个equalTo的宏定义调用了mas_equalTo，而mas_equalTo实际调用了equalTo函数只是将参数转换成了NSObject对象；所以我们可以得到以下结果：无论传入的参数是否是NSObject对象，equalTo和mas_equalTo最后调用的都是equalTo函数，需要注意的是equalTo宏定义和equalTo函数虽然本质调用一样，但是是属于不同函数； 关于Masonry的数据转换通过上面的宏定义我们存在一个疑惑点，为一个非NSObject对象可以被equalTo接受呢？原因就是下面这个函数噶会的作用； 对于所有传入的参数无论是否是NSObject对象，都会通过_MASBoxValue这个函数进行数据的封装，将所有参数都转换成一个NSObject对象 最后对于那些原本非NSObject对象在进行反向解析，设置对应的值； 关于Masonry的结构下图是网上一张很详细介绍Masonry结构的一张结构图，这里引用一下，因为我不想很具体的去介绍每一句代码，只把最核心的几点告诉大家； 上图的大致流程其实很通俗易懂，因为我们这样想，我们最主要的目的无非就是讲一个一个NSLayoutConstraint约束抽象成我们能够简单通俗的编写方式，所以Masonry的主要流程其实就是每个view提供给用户一个MASConstraintMaker对象，让用户不断在MASConstraintMaker对象上添加一个一个MASConstraint的约束结构，最后将所有的MASConstraint转化成一个一个NSLayoutConstraint对象添加在相应的view上面； 接下来的很多概念都需要用到上面的结构； 关于mas_makeConstraints，mas_updateConstraints，mas_remakeConstraints的区别理解我相信上面三个函数大家一定不会陌生，而且应该也知道对应的使用场景；mas_makeConstraints就是创建一个新的约束mas_updateConstraints就是更新一个原有的约束mas_remakeConstraints就是移除现有的约束，添加新的约束； 介绍一下主要的原理，每个MASConstraintMaker对象有两个updateExisting &amp;&amp; removeExisting属性，用来保存当前的maker的约束方式 所以当调用mas_makeConstraints &amp;&amp; mas_updateConstraints &amp;&amp; mas_remakeConstraints这三个函数的时候，最后都会去执行install这个操作，而install里面本身就会判断如果是remakeConstraints那么它就会移除所有旧的约束，然后添加新的约束；对于updateConstraints &amp;&amp; makeConstraints只是添加新的约束，但是MASConstraint本身会保存当前的约束是更新约束还是新加约束； 那么对于updateConstraints &amp;&amp; makeConstraints内部对于updateExisting的区别其实很简单，如果updateExisting为true，那么就从当前的view去找是否存在和当前约束一样的约束，然后更新约束的constant，我们可以从layoutConstraintSimilarTo函数可以看到，判断约束是否存在的标准就是除了constant以外的所有属性；如果updateExisting为false，那么就是直接添加新的约束； 关于Masonry为什么可以链式调用其实Masonry可以链式调用无非就是为了缩减代码量，没有其他任何原因；从我们之前的结构图可以看到MASConstraintMaker对象包函了大量的MASConstraint属性对象，而MASConstraint属性对象里面还是定义大量的MASConstraint属性，于是就可以不断返回MASConstraint的对象;于是问题来了，它是怎么做到将每个MASConstraint对象都保存起来呢？ 我们可以发现MASConstraint对象都有一个MASConstraintDelegate的代理，而MASConstraintMaker实现了这个代理，所以所有生成MASConstraint的任务其实最后都是通过MASConstraintMaker来实现的，并通过constraints进行保存； 关于Masonry如何正确添加对应的View关系可能很多人存在一个疑惑点，Masonry是如何正确的添加每个约束关系到对应的View上呢？不理解我这句话的同学可以自行写一个约束，然后打印对应的view的constraints可以发现，每个约束都有自己的对应关系，有的添加在superview上面，有些是添加在自己的view上面；那么Masonry是怎么做的呢？ 我们发现对于存在secondView的情况，那么firstView和secondView的最近公共view就是约束需要添加的view，如果firstView是设置size的大小（包括单独的宽高），那么需要添加约束的就是自身的view，其他情况一律都是firstView的superview（比如make.center.offset(10)这类操作）； 关于Masonry的一些缺省写法很多人会在代码中会写如下的代码，以下两段代码实现效果是一样的，但是其中一段是缺省代码，那么为什么缺省的写法也是可以正确实现呢？ 原因就在于Masonry会对系统的缺省值进行补充，如果在equalTo的时候传入secondViewAttribute是UIView对象，那么使用的约束类型就是该firstView的约束属性，如果传入的secondViewAttribute是secondView的约束属性，那么就直接使用； "},{"title":"组件化","date":"2020-05-23T07:03:52.000Z","url":"/23/%E7%BB%84%E4%BB%B6%E5%8C%96/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1.组件化有什么好处？ 业务分层、解耦，使代码变得可维护； 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护； 便于各业务功能拆分、抽离，实现真正的功能复用； 业务隔离，跨团队开发代码控制和版本风险控制的实现； 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力； 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App） 2.你是如何组件化解耦的？ 分层 基础功能组件：按功能分库，不涉及产品业务需求，跟库Library类似，通过良好的接口拱上层业务组件调用；不写入产品定制逻辑，通过扩展接口完成定制； 基础UI组件：各个业务模块依赖使用，但需要保持好定制扩展的设计 业务组件：业务功能间相对独立，相互间没有Model共享的依赖；业务之间的页面调用只能通过UIBus进行跳转；业务之间的逻辑Action调用只能通过服务提供； 中间件：target-action，url-block，protocol-class 3.为什么CTMediator方案优于基于Router的方案？Router的缺点： 在组件化的实施过程中，注册URL并不是充分必要条件。组件是不需要向组件管理器注册URL的，注册了URL之后，会造成不必要的内存常驻。注册URL的目的其实是一个服务发现的过程，在iOS领域中，服务发现的方式是不需要通过主动注册的，使用runtime就可以了。另外，注册部分的代码的维护是一个相对麻烦的事情，每一次支持新调用时，都要去维护一次注册列表。如果有调用被弃用了，是经常会忘记删项目的。runtime由于不存在注册过程，那就也不会产生维护的操作，维护成本就降低了。 由于通过runtime做到了服务的自动发现，拓展调用接口的任务就仅在于各自的模块，任何一次新接口添加，新业务添加，都不必去主工程做操作，十分透明。 在iOS领域里，一定是组件化的中间件为openURL提供服务，而不是openURL方式为组件化提供服务。如果在给App实施组件化方案的过程中是基于openURL的方案的话，有一个致命缺陷：非常规对象(不能被字符串化到URL中的对象，例如UIImage)无法参与本地组件间调度。 在本地调用中使用URL的方式其实是不必要的，如果业务工程师在本地间调度时需要给出URL，那么就不可避免要提供params，在调用时要提供哪些params是业务工程师很容易懵逼的地方。 为了支持传递非常规参数，蘑菇街的方案采用了protocol，这个会侵入业务。由于业务中的某个对象需要被调用，因此必须要符合某个可被调用的protocol，然而这个protocol又不存在于当前业务领域，于是当前业务就不得不依赖public Protocol。这对于将来的业务迁移是有非常大的影响的。 CTMediator的优点： 调用时，区分了本地应用调用和远程应用调用。本地应用调用为远程应用调用提供服务。 组件仅通过Action暴露可调用接口，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性。 方便传递各种类型的参数。 4.基于CTMediator的组件化方案，有哪些核心组成？ CTMediator中间件：集成就可以了 模块Target_%@：模块的实现及提供对外的方法调用Action_methodName，需要传参数时，都统一以NSDictionary*的形式传入。 CTMediator+%@扩展：扩展里声明了模块业务的对外接口，参数明确，这样外部调用者可以很容易理解如何调用接口。 "},{"title":"iOS-AFNetworking底层框架","date":"2020-04-26T07:34:40.000Z","url":"/26/iOS-AFNetworking%E5%BA%95%E5%B1%82%E6%A1%86%E6%9E%B6/","tags":[["开源框架","/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"AFNetworking是iOS开发中一个常用的网络请求第三方框架，我们常会这样子去发起一个请求 先来看看它在GitHub上是怎么解释的： AFNetworking is a delightful networking library for iOS, macOS, watchOS, and tvOS. It’s built on top of the Foundation URL Loading System, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.AFNetworking是一个非常适合iOS、macOS、watchOS和tvOS的网络库。它构建在Foundation URL加载系统之上，扩展了内置在Cocoa中的强大的高级网络抽象。它有一个模块化的架构，拥有精心设计的、功能丰富的api，使用起来很有趣。 大体来讲，就是上面字面上的意思啦，总结来讲就三个：网络库，高级网络抽象，丰富的api。 框架组成 我们一起来看看AFNetworking的框架组成： 从上面看，分为五大块 第一大块 AFURLSessionManager为AFNetworking的核心类，AFNetworking所展开的工作都会围绕这个类来进行，同样，AFNetworking有一个子类继承了它，这个类是AFHTTPSessionManager，它主要负责我们当前的业务逻辑处理 第二大块 请求的时候，我们需要做序列化，Serialization文件夹里就包含了我们请求和相应的序列化，这个序列化对于我们请求来说，它可能主要用来参数的拼接，header，parameters，多表单参数的提交，而对于当前的response，它取决于我们怎么去序列化返回来的数据是以二进制、json、xml，它都有不同的类去实现具体的功能，总的来说，Serialization这个文件夹里的类是处理序列化的，这个序列化分为请求和响应的序列化 第三大块 AFNetworlingReachabilityManager这个类相信大家对于这个应该不陌生，我们常常在开发中会有网络状态监测的需求，这个是类就是用来做网络检测的 第四大块 Security文件夹里的类，它是用来做安全认证的，比如证书的一些校验逻辑就是在这里面 第五大块 UIKit那个文件夹它是一个简单的扩展，它用来便利的提供我们的UI层来调用我们的业务逻辑 在探究更深入的层面之前，我们先说说HTTPS的流程，方便后面讲解的扩展 HTTPS的流程 总的来说，HTTPS的流程分为四阶段第一阶段：Client Hello第二阶段：Server Hello - Server Done -&gt; 验证当前 Server Trust第三阶段：证书效验（客户端进行）第四阶段：客户端产生Pre-master（预主秘钥）这个是怎么生成的？是苹果的框架CFNetWork通过随机数计算来的最后就是数据的通信 版本信息：包含了随机数（random_c&#x2F;random_s），支持的加密算法等信息，通过TCP发送给服务端；非对称加密（RSA）：客户端拿到公钥进行加密，服务器用私钥进行解密 ；对称加密：客户端和服务端用同一把秘钥进行加密和解密，叫做对称加密备注：非对称加密安全，但非常耗时，性能低，一般用于验证HTTPS，当HTTPS建立完成之后，我们就可以用对称加密来进行通讯，也就保证我们的数据安全性了。那这里也许有人会问，如果拿到公钥，那数据是不是就不安全了？答案：对称机密的秘钥是用 random_c + random_s + Pre-master生成的，用公钥加密后发送给服务端的，而我们进行通讯使用的秘钥是客户端和服务端的随机码加上预主秘钥产生的，所以，不会有问题 证书校验那HTTPS流程讲完了，但你有没有主要到一个问题，客户端是怎么进行证书效验的？AFNetworking是怎么处理的？ AFURLSessionManager是AFNetworking的核心类，它所展开的工作都是围绕这个来进行的，那我们就从这个类开始看起，看看是不是真的如所说的，它是一个管理控制中心类。大概浏览了下代码，找到NSURLSession的代理，发现ANetworking好像在这里做了处理，也许你会问到底是不是哦？那我们一起开分析下代码： tip1[challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]我们需要从delegate回来的challenge去查找接受服务挑战的方式是否就是信任证书这种方式。我们注意到challenge的类型是(NSURLAuthenticationChallenge *)，点进去可以看到，里面找到下面的代码 AFNetworking自己也说了，这是一个需要认证的保护空间，那我们再点进去看下，这回我们就能看到了 以上，就有了接收服务器挑战的方法的判断那既然它的authenticationMethod是NSURLAuthenticationMethodServerTrust，接下来就是验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现）我们看到这样一行代码 tip2[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]self.securityPolicy -&gt; ? Security是用来做安全认证的，那这里是不是来验证服务端是否值得信任的？（知识点慢慢串起来了哈）我们点进去看看： (1)if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;...&#125;如果有服务器域名、设置了允许信任无效或者过期证书（自签名证书）、需要验证域名、没有提供证书或者不验证证书，返回no (2) NSMutableArray *policies = [NSMutableArray array]; 装验证策略(3) 生成验证策略。如果要验证域名，就以域名为参数创建一个策略，否则创建默认的basicX509策略(4)SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);为serverTrust设置验证策略，用策略对serverTrust进行评估(5) 看上面注释(6)case AFSSLPinningModeCertificate: &#123;...&#125;这个模式表示用证书绑定(SSL Pinning)方式验证证书，需要客户端保存有服务端的证书拷贝，而客户端保存的证书存放在self.pinnedCertificates中。总的来说，这里面所做的操作就是将本地的证书设置为根证书，然后评估指定证书和策略的信任度，如果为可信的，我们再去遍历服务端的证书链，查看是否有与本地证书匹配的，如果有，则返回YES，否则返回NO。 (7)case AFSSLPinningModePublicKey: &#123;...&#125;这个就是公钥验证啦，同理，这里也需要有服务端的证书拷贝，才能进行证书公钥验证。总的逻辑是：从serverTrust拿到服务端所有可用证书的公钥，查看服务端的公钥有没有与本利公钥相同的，如果有，则验证通过，否则反之。 以上就是这个方法 - (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust forDomain:(NSString *)domain 里的所有逻辑啦(8) static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123;...&#125;验证服务器是否可信任的？重点就是这个方法了__Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out); tip3 如果信任评估通过，就从受保护空间里面拿出证书，回调给服务器，告诉服务，我信任你，你给我发送数据吧。如果信任评估没有通过，则取消挑战。 总的来说，HTTPS证书效验的过程就是这样子的啦。 1、证书链：是根证书以及根证书颁发的子证书组成的一系列证书链2、NSURLSessionAuthChallengeDisposition - 挑战处理类型NSURLSessionAuthChallengeUseCredential：使用指定的证书NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战NSURLSessionAuthChallengeRejectProtectionSpace：拒绝此挑战，并尝试下一个验证保护空间；忽略证书参数 "},{"title":"iOS CocoaPods私有库的创建和版本更新","date":"2020-03-25T11:04:06.000Z","url":"/25/iOS-CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/","tags":[["Cocoapods","/tags/Cocoapods/"]],"categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"一、添加repo库这里使用的代码托管平台是码云，因为GitHub之前创建私有库需要收费而码云不用收费 repo是用来管理Pod索引的库，所有一个repo可以管理多个Pod索引，添加repo库需要一个远程Git库，添加repo即将Git库clone到本地 创建远程Git仓库新建仓库 配置仓库 添加远程索引库 查看pod repo的所有命令 查看本地所有的repo 复制Git仓库地址 重新查看本地所有的repo 二、 创建CocoaPods私有库官方文档：Using Pod Lib Create 创建pod库的远程Git仓库配置Git仓库 复制Git仓库地址 创建Pod库 Pod库的目录结构 打开测试工程并删除ReplaceMe.m文件 Development Pods与普通CocoaPods的不同之处在于它们是符号链接文件，因此对其进行编辑将更改原始文件，因此你可以从Xcode内部处理库。 你的演示和测试将需要使用#import &lt;MyLib / XYZ.h&gt;格式包含对标头的引用。 新建NSString类目 注意：这边新建的文件需要指定放到源码目录（这边是Classes，需要于.podspec文件中的source_files对应） 添加类方法 重新pod install 文件重新排列 导入文件添加代码 运行结果 编辑.podspec配置文件 版本发布 Pod远程Git仓库 注意：标签的内容为.podspec文件的s.version的值，即pod的版本号 验证pod库 验证spec配置文件 通过设置同一个&lt;索引库名&gt;不同的&lt;.podspec文件名&gt;来实现同一个repo包含多个Pod库 推送版本 repo远程Git仓库 repo远程Git仓库 4、测试Pod库是否发布成功 新建项目PrivatePodDemo，在终端进入项目根目录执行 创建Podfile文件，点击i进入编辑状态，编辑Podfile文件，点击esc后输入:wq退出编辑状态，执行 集成CocoaPods 编辑Podfile 添加测试代码并运行 三、CocoaPods私有库更新版本 修改源码添加方法 修改.podspec文件中的版本号 Git推送到远程仓库 注意添加标签tag，tag的内容必须与修改完成的.podspec文件中的版本号一致 推送版本 验证pod和spec 推送repo 测试版本更新是否成功 使用 pod search &lt;pod库名称&gt;搜索Pod库 执行pod update 注意：更新pod库需要使用pod update而不是pod install，这里使用pod update是更新集成的所有Pod库，pod update &lt;Pod库名&gt;可以更新指定的Pod库 源码更新 运行结果 6.更新Pod库可能会碰到的问题 更新pod库报错 解决方法：在Podfile文件中添加 添加源码地址 四、CocoaPods的配置 添加图片和Bundle将图片和Bundle复制到Pod工程目录 修改.podspec配置文件对应的图片和Bundle参数 更新Pod之后 "},{"title":"Flutter简介","date":"2020-02-23T08:01:31.000Z","url":"/23/Flutter%E7%AE%80%E4%BB%8B/","categories":[["Flutter","/categories/Flutter/"]],"content":"1. Flutter简介Flutter是一个由Google与社区开发的开源移动应用软件开发工具包，是一款移动应用程序SDK，包含框架、widget和工具，为开发人员提供了一种在Android和iOS上构建和部署精美移动应用程序的简单高效的方式。 目前，移动跨平台技术方案主要分为三类： 第一类： 使用原生内置浏览器加载HTML5的Hybrid技术方案，采用此类方案的主要有Cordova、ionic和微信小程序； 第二类： 使用JavaScript进行开发，然后使用原生组件进行渲染的方案，采用此类方案的主要有React Native、Weex和快应用； 第三类： 是使用自带的渲染引擎和自带的原生组件来实现跨平台的方案，采用此类方案的主要是Flutter。 Flutter不是一个彻底的跨平台技术框架，如果应用开发中涉及混合开发，还需要开发者具备原生开发知识。 Android平台大多使用Java（或Kotlin），iOS平台大多使用Objective-C（或Swift）。 1.1 Flutter的特点1）跨平台开发 Flutter支持在mac OS、Windows、Linux、Android、iOS以及谷歌公司的Fuchsia操作系统上运行。同时，Flutter可以真正做到一套代码同时运行在Android、iOS和Web平台上，避免过高的开发和维护成本，节约资源。 2）符合不同平台的用户体验 Flutter内置了Material和Cupertino风格的组件，为开发者开发Android和iOS平台风格的应用提供了便捷。同时，Flutter提供的motion API、平滑而自然的滑动效果和平台感知，为用户带来全新体验。 3）响应式框架 使用Flutter的响应式框架和一系列基础组件，可以轻松地完成用户界面（UI）的构建。同时，功能强大且灵活的API可以帮助开发者解决复杂的UI构建问题。 4）跨平台渲染引擎 Flutter使用Skia作为其二维渲染引擎，不需要像React Native那样在JavaScript和Native之间通信，从而减少了性能开销。 5）支持本地访问和插件 通过Flutter提供的插件，开发者可以访问原生平台的API，如蓝牙、相机和Wi-Fi等。同时，Flutter还可以复用Java、Swift或Objective-C代码，访问原生Android和iOS系统的功能。 6）高性能 Flutter采用GPU渲染技术，使用Flutter编写的应用运行画面基本可以达到60帧&#x2F;秒，因此使用Flutter开发的应用几乎可以媲美原生应用的性能。 7）使用Dart进行应用开发 在即时（Just In Time，JIT）编译模式下Dart的速度与JavaScript基本持平；在静态（Ahead Of Time，AOT）编译模式下运行时，Dart的性能远高于JavaScript。 Flutter在应用开发阶段采用JIT编译模式，避免每次改动代码都需要重新编译的问题，极大地节省了开发时间。而基于AOT发布包，使Flutter在发布时可以通过AOT生成高效的ARM代码，以保证应用性能。 1.2 Flutter版本1）master版本 代码是最新的，包含最新的功能和特性，但是代码没有经过测试，可能会出现各种各样的缺陷。 2）dev版本 通过谷歌公司内部测试的最新版本，测试只是最基础的测试，一旦发现有严重的阻塞性的缺陷，这个版本就会被废弃。 3）beta版本 每个月初Flutter团队会将上一个稳定的dev版选为beta版进行发布，此版本通常是经过线上运行的dev版，没有新的、严重的缺陷。 4）stable版本 是从beta版本中选出的版本，一个季度更新一次或多次。 总体来说，用于正式的生产环境一定要选stable版。 1.3 Flutter框架Flutter是一个分层结构框架，每一层都建立在前一层的基础上。它主要包括三大层级，Framework（视图层）、Engine（引擎层）和Embedder（嵌入层），其中App都是基于Framework开发并运行在Engine层上的。 Framework（视图层） 是一个由Dart实现的软件开发工具包（Software Development Kit，SDK），它提供了一整套自下而上的基础库。 1）底下两层：Foundation、Animation、Painting、Gestures被合并为Dart UI层，对应Flutter中的dart:ui包，它是引擎暴露的底层UI库，提供动画、手势识别及图形绘制功能。 2）Rendering层：抽象的布局层，负责构建UI对应的树结构。当UI树上的元素发生变化时，它会计算出有变化的部分并更新UI树，最终将UI树绘制到屏幕上展示给用户，整个过程类似于React中的虚拟文档对象模型（DOM）。 3）Widgets层：Flutter在基础组件库之上，还提供了Material和Cupertino两种视觉风格的组件库。 Engine（引擎层） 是一个由C&#x2F;C++实现的软件开发工具包（SDK），是Flutter的引擎，主要由Skia引擎、Dart运行时和文字排版引擎构成。Skia是开源的图形库，提供适用于多种软硬件平台的API；Dart层包含了在Dart运行时的垃圾收集、JIT编译、AOT编译；Text则负责文本渲染。 当Framework层调用dart:ui包时，最终都会走到Engine层，然后由Engine层实现真正的绘制逻辑。 Embedder（操作系统适配层&#x2F;嵌入层） Embedder层能确保各平台的兼容性。在Android和iOS平台上，Embedder层负责将上层完美地嵌入到它们中。上层只提供画布，所有内容的绘制渲染逻辑均在Flutter内部完成，这实现了Flutter App和平台的无关性。"},{"title":"Charles iOS抓https包","date":"2020-01-20T08:10:16.000Z","url":"/20/Charles-iOS%E6%8A%93https%E5%8C%85/","categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":" iPhone 连mac IP 代理 Charles -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate -&gt; 钥匙串里找到Charles证书点击完全信任 Charles -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device orRemote Browser -&gt; 弹框 -&gt; OK iPhone -&gt; Safari -&gt; chls.pro&#x2F;ssl 下载证书，安装证书 Charles -&gt; Proxy-SSL -&gt; Proxying settings -&gt; Add -&gt; port -&gt;443 ps iOS新版本系统无法抓到https包，手机通用-关于本机-最下面“证书信任设置”，找到Charles proxy 把开关打开就可以了 "},{"title":"iOS 自动化打包","date":"2019-12-13T07:25:38.000Z","url":"/13/iOS-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"伴随着Xcode11把Application Loader删除了。打包上架变得又慢又卡，那么有什么好的办法来实现一键打包并上架到App Store或者上传到第三方分发平台呢。 一、shell脚本打包1、自动打包首先需要两个文件，第一个是配置plist，第二个shell脚本。 1.1 plist文件 注意 method是根据打包的方式不同而有所区别，ad-hoc或是app-store那么我们怎么去获取这个plist文件呢，这里我们用Xcode去打包一次，得到如下文件。 文件夹中ExportOptions.plist就是我们想要的plist文件了，拷贝出来备用。 1.2 shell脚本 注意： 1.更换自己的工程名字、打包模式、scheme名、以及plist文件路径。2.注意自己项目是否是普通工程还是cocoapods工程，这里的脚本会不一样。 1.3 实战如下 工程目录 1.4 总结到此，我们就可以用终端一条命令实现打包，避免了繁琐的Xcode打包处理。 2、自动打包并上传到App Store、蒲公英、fir平台2.1 注备阶段安装fir-cli插件文档 出现如下错误 使用如下命令 又出现如下错误 根据上面的错误提示，让我们尝试使用gem install rubyzip -v 1.3.0 这条命令 错误如下 似曾相识，就是第一条的错误使用sudo 出现如上界面，安装成功了重大提醒fir.im 更换域名后, 需要升级至 fir-cli &gt;= 2.0.4 有部分用户反馈 2.0.2 无法直接使用 gem update fir-cli 升级到 2.0.4, 则可以尝试卸载后重新安装, 即 gem uninstall fir-cli 后 gem install fir-cli重大提醒fir更新文档 2.2 shell脚本配置 2.3 上传到App Store 上传App Store 构建版本 注意： 如果你报如下错误，不难看出，是因为我们开启了双重认证，需要app-specific password。接下来你需要去生成动态密码即可。 2.4 上传蒲公英 2.5 上传fir 二、fastlane打包2.1 注备阶段安装fastlane 错误如下 根据上面的错误提示，让我们尝试使用gem install signet -v 0.11.0 这条命令 错误如下 还是老问题，没有权限，使用sudo 成功之后在执行 出现如上界面，安装成功了!拓展 第一点 Podfile.lock的作用防止多人开发本地CocoaPods版本不一致 2.2 接下来我们正式使用fastlane 这里让我们选择打包到App Store和TestFlight。这里我们选择2。如果你出现如下结果，已经卡死在这里了，选择退出。 使用如下命令。 我们来看下fastlane文件夹中的Fastfile 可以看出打包模式只有testflight，之后我们会满满丰满这里面的内容，且往下看。 继续使用如下命令 选择打包方式 注意 1是打包到TestFlight,与Fastfile文件中的平台对应因为我们开启了双向认证，所以输入我们的双向认证密码。 打包成功，这里可以看到很多信息，比如版本，build号以及打包所用的时间。 2.3 把ipa上传到第三方平台首先我们需要安装插件，首先看看如下几个命令。查询插件 安装蒲公英插件 安装fir插件 安装成功后，可以在当前目录的fastlane下生成一个Pluginfile文件，文件内容如下 现在我们开始丰满一下我们的Fastfile的platform信息 重新输入 可以看出来，目前有四种方式选择，分别对应我们的TestFlight、线上release、蒲公英以及fir。 接下来我们以蒲公英为例（其他平台方式都一致）: 可以看到上传成功 fastlane成功! 注意 可能是你安装pgyer插件的时候，不是在项目下安装的，这个插件必须在项目下面安装。 到此，我们的fastlane就已经实现了自动化打包。"},{"title":"iOS开发常用设计模式","date":"2019-08-14T12:27:38.000Z","url":"/14/iOS%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"在软件开发中，无论是那种高级语言中总会伴随着一些最为常用的设计模式，下面针对iOS中，MVC模式、代理模式、观察者模式、单例模式、策略模式、简单工厂模式这六大模式进行汇总分析。 一、MVC模式MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑 1.1实例MVC(Model View Controller)模型(model)－视图(view)－控制器(controller) 1.1.1模型对象模型对象封装了应用程序的数据，并定义操控和处理该数据的逻辑和运算。例如，模型对象可能是表示游戏中的角色或地址簿中的联系人。用户在视图层中所进行的创建或修改数据的操作，通过控制器对象传达出去，最终会创建或更新模型对象。模型对象更改时（例如通过网络连接接收到新数据），它通知控制器对象，控制器对象更新相应的视图对象。 1.1.2视图对象视图对象是应用程序中用户可以看见的对象。视图对象知道如何将自己绘制出来，并可能对用户的操作作出响应。视图对象的主要目的，就是显示来自应用程序模型对象的数据，并使该数据可被编辑。尽管如此，在 MVC 应用程序中，视图对象通常与模型对象分离。 在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，对应MVC中的V。UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。 1.1.3控制器对象在应用程序的一个或多个视图对象和一个或多个模型对象之间，控制器对象充当媒介。控制器对象因此是同步管道程序，通过它，视图对象了解模型对象的更改，反之亦然。控制器对象还可以为应用程序执行设置和协调任务，并管理其他对象的生命周期。 1.2应用场景MVC模式是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。 1.3优势MVC模式使系统，层次清晰，职责分明，易于维护 1.4敏捷原则MVC模式对扩展开放-对修改封闭 二、代理模式代理模式完成委托方交给的任务,委托方有一些任务自己不想完成,但是还需要要实现,则将该任务存放到协议中,由代理完成.但是代理并不会主动的执行任务,需要委托方通知代理。 2.1应用场景当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。 2.2优势解耦合 2.3敏捷原则开放-封闭原则 2.4实例tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate，自定义的delegate。 三、观察者模式观察者模式本质上是一种发布-订阅模型,用以消除具有不同行为的对象之间的耦合，通过这一模式，不同对象可以协同工作，同时它们也可以被复用于其他地方Observer从Subject订阅通知，ConcreteObserver实现重现ObServer并将其重载其update方法。 3.1应用场景一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。 3.2优势解耦合 3.3敏捷原则接口隔离原则，开放-封闭原则 3.4实例Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。 kvo，键值对改变通知的观察者，平时基本没用过。 四、单例模式单例模式可以保证App在程序运行中，一个类只有唯一个实例，从而做到节约内存。 在整个App程序中，这一份资源是共享的。 提供一个固定的实例创建方法。 4.1应用场景确保程序运行期某个类，只有一份实例，用于进行资源共享控制。 4.2优势使用简单，延时求值，易于跨模块 4.3敏捷原则单一职责原则 4.4实例[UIApplication sharedApplication]。 4.5注意事项确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。 java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。 object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例， 返回的也只是此单例类的唯一静态变量。 五、策略模式策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 5.1应用场景定义算法族，封装起来，使他们之间可以相互替换。 5.2优势使算法的变化独立于使用算法的用户 5.3敏捷原则接口隔离原则； 多用组合，少用继承； 针对接口编程，而非实现。 5.4实例排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。 5.5注意事项1、剥离类中易于变化的行为，通过组合的方式嵌入抽象基类 2、变化的行为抽象基类为，所有可变变化的父类 3、用户类的最终实例，通过注入行为实例的方式，设定易变行为 防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。 六、简单工厂模式简单工厂模式中定义一个抽象类，抽象类中声明公共的特征及属性，抽象子类继承自抽象类，去实现具体的操作。工厂类根据外界需求，在工厂类中创建对应的抽象子类实例并传给外界，而对象的创建是由外界决定的。外界只需要知道抽象子类对应的参数即可，而不需要知道抽象子类的创建过程，在外界使用时甚至不用引入抽象子类。 6.1应用场景工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。 6.2优势易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。 6.3敏捷原则DIP依赖倒置原则 6.4实例项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换 6.5注意事项项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，增加了代码的复杂度，增加了调用层次，增加了内存负担。"},{"title":"Git常见命令","date":"2019-07-23T13:19:22.000Z","url":"/23/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/","tags":[["git","/tags/git/"]],"categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"git config配置 Git 的相关参数。 Git 一共有3个配置文件： 仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。 全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\\Users\\&lt;用户名&gt;\\.gitconfig。 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。 git clone从远程仓库克隆一个版本库到本地。 git init初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。 git status查看本地仓库的状态。 git remote操作远程库。 git branch操作 Git 的分支命令。 git checkout检出命令，用于创建、切换分支等。 git cherry-pick把已经提交的记录合并到当前分支。 git add把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。 git commit将暂存区中的文件提交到本地仓库中。 git fetch从远程仓库获取最新的版本到本地的 tmp 分支上。 git merge合并分支。 git diff比较版本之间的差异。 git pull从远程仓库获取最新版本并合并到本地。首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。 git push把本地仓库的提交推送到远程仓库。 git log显示提交的记录。 git reset还原提交记录。 git revert生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。 git tag操作标签的命令。 git mv重命名文件或者文件夹。 git rm删除文件或者文件夹。 Git操作场景示例1. 删除掉本地不存在的远程分支多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除： "},{"title":"iOS 消息推送","date":"2019-06-16T02:18:15.000Z","url":"/16/iOS-%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"现在为我们的项目添加推送功能有两种方式 1：使用Token Authentication (p8)方式，也是现在推荐的方式Token Authentication (p8)是 APNs 新推出的推送鉴权方式，这种新的方式有很多优势 同一个账户下所有 App 无论是测试 App 还是正式版 App，都能使用同一个 key 来发推送消息和 voice-over-Internet Protocol (VoIP) 消息，不再需要为每个 App 生成一个证书 生成的 Auth Key 不再有过期时间，无需像证书那样每年需要重新生成一次 生成过程简单，不需要繁琐、易错的证书导出操作 创建Token Authentication (p8) 点击keys旁边的添加，然后我们勾选图中的选择，点击continue 下载后会有一个.p8文件，AuthKey_keyxxxxx.p8 如果我们使用第三方推送，比如友盟，个推等，我们还需要Team ID 这里以友盟推送示列，我们去友盟上配置一下，最后点击确认添加，如果不出意外，添加成功 2：使用证书的方式来添加消息推送1：从CA请求证书 2：苹果开发者网站创建推送证书，点击+号 我们创建开发和发布环境都支持的证书 选择我们要创建推送证书的App ID，绑定证书与App的关系，这个App就可以实现消息推送功能 选择刚刚创建的CA证书 创建成功，下载证书，并添加到钥匙串中 导出.p12文件备用 3：如果之前创建了App ID，我们需要为此App ID开启推送 4：如果已经创建描述文件，需要重新保存 5：使用证书方式推送，我们去友盟为此方式进行配置 3：设置xcode，开启推送功能在xcode中为我们的项目打开我们的消息推送功能 其他消息推送功能也记录下，关于app后台运行的功能 voice over ip 简称voip，需要配置证书，如果你的项目包含语音通话，类似微信语音视频功能，可以选择此项，app处于后台或者杀死app，收到此消息都会唤醒app执行一个方法，审核需要提供呼叫功能演示视频Remote nitifications 静默推送，推送方式类似消息推送，不过不会弹出消息框，app处于后台会被唤醒调用一个方法，我们可以在这个方法中处理一些事情，但是杀掉app就收不到此推送APNS 普通消息推送，app处于后台或者杀死app都能收到，但不会唤醒app调用方法 这里我选择开启后台的静默推送 添加推送的代码，使用友盟推送 4：遇到的坑，关于使用友盟推送遇到的问题记录使用友盟推送时，当我们使用development证书调试时，无法收到推送的消息，推送失败如下device-token全部失败 我们可以发现下图中，debug下选择的development证书的ID与TeamID不相同 development 我们看看release下选择的distribution证书ID和TeamID是相同的 distribution 尝试在debug下使用distribution证书，真机无法运行起来 解决办法1：将程序打包成Ad hoc安装，这样就可以收到消息推送解决办法2：使用测试消息推送的工具，比如Pusher，测试工具需要选择证书推送的情况下才能使用 5：记录下消息推送的格式iOS10之前的格式 iOS 10及之后(iOS7、iOS8、iOS9可通用此模板) "},{"title":"iOS 中常见 Crash 总结","date":"2019-05-17T13:14:38.000Z","url":"/17/iOS-%E4%B8%AD%E5%B8%B8%E8%A7%81-Crash-%E6%80%BB%E7%BB%93/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":" 1、找不到方法的实现unrecognized selector sent to instance 2、KVC造成的crash 3、EXC_BAD_ACCESS 4、KVO引起的崩溃 5、集合类相关崩溃 6、多线程中的崩溃 7、Socket长连接，进入后台没有关闭 8、Watch Dog超时造成的crash 9、后台返回NSNull导致的崩溃，多见于Java做后台服务器开发语言 1、找不到方法的实现unrecognized selector sent to instance1.1、场景对应的Code 1.2、原因 找不到方法iOS系统抛出异常崩溃 1.3、解决方案1、给NSObject添加一个分类，实现消息转发的几个方法 2、尽量避免使用performSelector一系列方法 3、delegate 方法调用前进行 respondsToSelector 判断，或者Release模式下使用ProtocolKit给协议添加默认实现防止崩溃，Debug模式下关闭默认实现 4、属性和成员变量不要重名定义，合理使用 synthesize 生成属性的 setter 和 getter 方法 5、在MRC模式下，变量的 retain 和 release 要谨慎，建议采用安全 release方法，即 release 的对象置为 nil 6、在.h中声明的方法如果用不到就去掉，用得到就同时在.m文件中实现 7、可变属性（如NSMutableArray），不要使用copy修饰，或者重写set方法 8、使用高版本的系统方法的时候做判断 1.4、知识归纳：参考runtime 消息转发 消息转发机制主要包含三个步骤： 1、动态方法解析阶段 2、备用接收者阶段 3、完整消息转发阶段 和 2、KVC造成的crash2.1、场景对应的Code 2.2、原因 给不存在的key（包括key为nil）设置value 2.3、解决方案：1、如果属性存在，利用iOS的反射机制来规避，NSStringFromSelector(@selector())将SEL反射为字符串作为key。这样在@selector()中传入方法名的过程中，编译器会有合法性检查，如果方法不存在或未实现会报黄色警告。 2、重写类的setValue:forUndefinedKey:和valueForUndefinedKey: 3、EXC_BAD_ACCESS 经过ARC的洗礼之后，普通的访问释放对象产生的EXC_BAD_ACCESS已经大量减少了，现在出现的EXC_BAD_ACCESS有很大一部分来自malloc的对象或者越界访问。 3.1、场景对应的Code 3.2、原因 出现悬挂指针，对象没有被初始化，或者访问的对象被释放 3.3、解决方案：1、Debug阶段开启僵尸模式，Release时关闭僵尸模式 2、使用Xcode的Address Sanitizer检查地址访问越界 3、创建对象的时候记得初始化 4、对象的属性使用正确的修饰方式（strong/weak） 5、调用block的时候，做判断 4、KVO引起的崩溃4.1、场景对应的Code 4.2、原因 添加了观察者，没有在正确的时机移除 4.3、解决方案：1、addObserver和removeObserver一定要成对出现， 2、推荐使用FaceBook开源的第三方库 FBKVOController 5、集合类相关崩溃5.1、场景对应的Code 5.2、原因 越界、添加nil、多线程非原子性操作、遍历的同时移除元素 5.3、场景： 1、数组越界，访问下标大于数组的个数 2、向数组中添加空数据 3、多线程环境中，一个线程在读取，一个线程在移除 4、一边遍历数组，一边移除数组中的元素 5、多线程中操作可变数组（数组的扩容、访问僵尸对象） 5.4、解决方案： 1、给集合类添加category重写原来的方法，在内部做判断 2、使用Runtime把原来的方法替换成自定义的安全方法 3、给NSMutableDictionary添加元素的时候，使用setObject:forKey:向字典中添加value为nil的键值对，推荐使用KVC的setValue:nil forKey:。[mutableDictionary setValue:nil ForKey:@&quot;name&quot;]不会崩溃，只是从字典中移除name键值对。 4、因为NSMutableArray、NSMutableDictionary不是线程安全的，所以在多线程环境下要保证读写操作的原子性，使用 加锁 、信号量 、GCD串行队列 、GCD栅栏dispatch_barrier_async、CGD组的dispatch_group_enter和dispatch_group_leave 6、多线程中的崩溃6.1、场景对应的Code 6.2、原因 死锁、子线程中更新UI、多个线程同时释放一个对象 6.3、场景1、在子线程中更新UI 2、dispatch_group crash，dispatch_group_leave的次数比dispatch_group_enter次数多。 参考：iOS疑难问题排查之深入探究dispatch_group crash 3、多线程下非线程安全类的使用，如NSMutableArray、NSMutableDictionary。NSCache是线程安全的。 4、数据缓存到磁盘和读取。 6.4、解决方案：多线程遇到需要同步的时候，加锁，添加信号量等进行同步操作。一般多线程发生的Crash，会收到SIGSEGV信号，表明试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据。 7、Socket长连接，进入后台没有关闭 当服务器close一个连接时，若client端接着发数据。根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。而根据信号的默认处理规则，SIGPIPE信号的默认执行动作是terminate(终止、退出),所以client会退出。 长连接socket或重定向管道进入后台，没有关闭导致崩溃的解决办法： 7.1、解决方案： 方法一：1、切换到后台是，关闭长连接和管道，回到前台重新创建。 方法二：2、使用signal(SIGPIPE,SIG_IGN)，将SIGPIP交给系统处理，这么做将SIGPIPE设为SIG_IGN，使客户端不执行默认操作，即不退出。 8、Watch Dog超时造成的crash 主线程执行耗时操作，导致主线程被卡超过一定时间。一般异常编码是0x8badf00d，表示应用发生watch dog超时而被iOS终止，通常是应用花费太多的时间无法启动、终止或者响应系统事件。 8.1、解决方案： 主线程只负责更新UI和事件响应，将耗时操作（网络请求、数据库读写等）异步放到后台线程执行。 9、后台返回NSNull导致的崩溃，多见于Java做后台服务器开发语言9.1、场景对应的Code NULL：用于普通类型，例如NSInteger nil：用于OC对象（除了类这个对象）,给nil对象发送消息不会crash Nil：用于Class类型对象的赋值（类是元类的实例，也是对象） NSNull：用于OC对象的站位，一般会作为集合中的占位元素，给NSNull对象发送消息会crash的，后台给我们返回的就是NSNull对象 9.2、解决方法 利用消息转发。参考：NullSafe。当我们给一个NSNull对象发送消息的话，可能会崩溃（null是有内存的），而发送给nil的话，是不会崩溃的。 10、在iOS中捕获异常信息 崩溃主要是由于 Mach` 异常、`Objective-C` 异常（`NSException`）引起的，同时对于 Mach 异常，到了 ```BSD 层会转换为对应的 Signal` 信号，那么我们也可以通过捕获信号，来捕获 Crash 事件。针对 ```NSException 可以通过注册 &#96;&#96;&#96;NSUncaughtExceptionHandler&#96; 捕获异常信息。 "},{"title":"runtime(三)：基本使用场景","date":"2019-05-08T14:02:28.000Z","url":"/08/runtime-%E4%B8%89-%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","tags":[["runtime","/tags/runtime/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、方法替换项目代码编写中，常会遇见第三方框架或者原生方法无法满足需求时或是一个方法在工程中大量被调用时，我们想要批量替换或修改，为了避免更改原有功能，**在保持原有方法功能基础上，添加额外的功能**，此时就需要用到Swizzle Method 方法替换Swizzle Method，目的是为了替换方法的实现。 平时实现某一方法时用到@selector，而能够实现方法是在@selector(方法选择器)中取出一方法编号(指向方法的指针)，用SEL类型表示，它所指向的是一IMP(方法实现的指针)，而方法替换的就是这个IMP，从而实现方法的替换 实例方法替换 类方法替换 替换方法的使用 为了确保Swizzle Method方法替换能一定被执行调用，因此需要在load中执行（在装载类文件时就会被调用（程序启动前）） 为了避免子类或子类的子类调用了[super load]而导致Swizzling被执行了多次（相当于SEL和IMP被交换了多次。这就会导致第一次执行成功交换了、第二次执行又换回去了、第三次执行…..这样换来换去的结果），需要在load中使用GCD方法dispatch_once确保方法只被执行一次并且**不需要**调用[super load]方法 二、实现分类添加新属性我们在开发中常常使用类目Category为一些已有的类扩展功能。虽然继承也能够为已有类增加新的方法，而且相比类目更是具有增加属性的优势，但是继承毕竟是一个重量级的操作，添加不必要的继承关系无疑增加了代码的复杂度。 遗憾的是，OC的类目并不支持直接添加属性，如果我们直接在分类的声明中写入Property属性，那么只能为其生成set与get方法声明，却不能生成成员变量，直接调用这些属性还会造成崩溃。 所以为了实现给分类添加属性，我们还需借助Runtime的关联对象(Associated Objects)特性，它能够帮助我们在运行阶段将任意的属性关联到一个对象上，下面是相关的三个方法： 注意：key与关联属性一一对应，我们必须确保其全局唯一性，常用我们使用@selector(methodName)作为key。 现在演示一个代码示例: 创建分类并声明一个属性 分类中属性实现 代码调用 三、获取类的详细信息1.获取属性列表 2.获取所有成员变量 3.获取所有方法 4.获取当前遵循的所有协议 四、方法动态解析与消息转发其实该部分可以参考runtime第一篇中内容，这里不再重复赘述，只是大概做出一些总结。 1.动态方法解析：动态添加方法Runtime足够强大，能够让我们在运行时动态添加一个未实现的方法，这个功能主要有两个应用场景： 场景1：动态添加未实现方法，解决代码中因为方法未找到而报错的问题； 场景2：利用懒加载思路，若一个类有很多个方法，同时加载到内存中会耗费资源，可以使用动态解析添加方法。方法动态解析主要用到的方法如下： 2.解决方法无响应崩溃问题执行OC方法其实就是一个发送消息的过程，若方法未实现，我们可以利用方法动态解析与消息转发来避免程序崩溃，这主要涉及下面一个处理未实现消息的过程： 除了上述的方法动态解析，还使用到的相关方法如下： 消息接收者重定向 消息重定向 "},{"title":"runtime(二)：runtime相关术语及数据结构","date":"2019-04-25T07:13:32.000Z","url":"/25/runtime-%E4%BA%8C-%EF%BC%9Aruntime%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":[["runtime","/tags/runtime/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"要想全面了解 Runtime 机制，我们还要了解 Runtime 的一些术语，他们都对应着数据结构。 Runtime数据结构在Objective-C中，使用[receiver message]语法并不会马上执行receiver对象的message方法的代码，而是向receiver发送一条message消息，这条消息可能由receiver来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实[receiver message]被编译器转化为：id objc_msgSend ( id self, SEL op, ... );下面从两个数据结构id和SEL来逐步分析和理解Runtime有哪些重要的数据结构。 SELSEL是函数objc_msgSend第二个参数的数据类型，表示方法选择器，按下面路径打开objc.h文件： 查看到SEL数据结构如下： SEL是selector在 Objc 中的表示(Swift 中是 Selector 类)。selector 是方法选择器，其实作用就和名字一样，日常生活中，我们通过人名辨别谁是谁，注意 Objc 在相同的类中不会有命名相同的两个方法。selector 对方法名进行包装，以便找到对应的方法实现. 我们可以看出它就是映射到方法的C字符串，你可以通过Objc编译器命令@selector()或者Runtime系统的sel_registerName函数来获取一个SEL类型的方法选择器。 如果你知道selector对应的方法名是什么，可以通过NSString* NSStringFromSelector(SEL aSelector)方法将SEL转化为字符串，再用NSLog打印。 注意： 不同类中相同名字的方法所对应的 selector 是相同的，由于变量的类型不同，所以不会导致它们调用方法实现混乱。 idobjc_msgSend第一个参数的数据类型id，id是通用类型指针，能够表示任何对象。打开路径同上。 查看到id数据结构如下： id其实就是一个指向objc_object结构体指针，它包含一个Class isa成员，根据isa指针就可以可以找到对象所属的类。 注意：根据Apple的官方文档Key-Value Observing Implementation Details提及，key-value observing是使用isa-swizzling的技术实现的，isa指针在运行时被修改，指向一个中间类而不是真正的类。所以，你不应该使用isa指针来确定类的关系，而是使用class方法来确定实例对象的类。 Classisa指针的数据类型是Class，Class表示对象所属的类，按下面路径可查看定义及数据结构： 可以查看到Class其实就是一个objc_class结构体指针，objc_class结构体的定义如下： 从 objc_class 可以看到，一个运行时类中关联了它的父类指针、类名、成员变量、方法、缓存以及附属的协议。 让我们分析一些重要的成员变量表示什么意思和对应使用哪些数据结构。 1. isa: objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。其实Meta Class也是一个Class，那么它也跟其他Class一样有自己的isa和super_class指针，实例对象中的isa指向对应的Class类，Class类中的isa指向metaClass关系如下： 上图实线是super_class指针，虚线是isa指针。有几个关键点需要解释以下： Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。 每个Class都有一个isa指针指向唯一的Meta class Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。 每个Meta class的isa指针都指向Root class (meta)。 **2. super_class: **指向当前类对应的父类，如果已经是最顶层的类（NSObject 、NSProxy）super_class为NULL； **3. name: ** 表示类名； 4.ivars: 表示多个成员变量列表，它指向objc_ivar_list结构体。在runtime.h可以看到它的定义： objc_ivar_list其实就是一个链表，存储多个objc_ivar，而objc_ivar结构体存储类的单个成员变量信息。 5.methodLists: 表示方法列表，它指向objc_method_list结构体的二级指针，可以动态修改*methodLists的值来添加成员方法，也是Category实现原理，同样也解释Category不能添加属性的原因。在runtime.h可以看到它的定义： 6.cache: 用来缓存经常访问的方法，它指向objc_cache结构体，后面会重点讲到。 7.protocols: 表示类遵循哪些协议。 MethodMethod表示类中的某个方法，在runtime.h中的定义： 其实Method就是一个指向objc_method结构体指针，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息： 1、方法名类型为 SEL 2、方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型 3、method_imp 指向了方法的实现，类型是IMP，本质是一个函数指针，后面会重点提及。 IvarIvar表示类中的实例变量，在runtime.h中的定义： Ivar其实就是一个指向objc_ivar结构体指针，它包含了变量名(ivar_name)、变量类型(ivar_type)等信息，其中 ivar_offset 是基地址偏移字节。 IMP在上面讲Method时就说过，IMP本质上就是一个函数指针，指向方法的实现，在objc.h找到它的定义： 它就是一个函数指针，当你向某个对象发送一条信息，可以由这个函数指针来指定方法的实现，它最终就会执行那段代码，这样可以绕开消息传递阶段而去执行另一个方法实现。你会发现 IMP指向的方法与 objc_msgSend 函数类型相同，参数都包含 id和SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。而一个确定的方法也只有唯一的一组 id 和 SEL 参数。 CacheCache主要用来缓存，在runtime.h文件的定义： Cache其实就是一个存储Method的链表，主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。"},{"title":"runtime(一)：runtime基础介绍","date":"2019-04-12T12:22:23.000Z","url":"/12/runtime-%EF%BC%9Aruntime%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/","tags":[["runtime","/tags/runtime/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、什么是 runtime？都说 Objective-C 是一门动态语言。首先，动态与静态语言最大的区别，就是动态语言将数据类型的检查等决策尽可能地从程序编译时推迟到了运行时。只要有可能，runtime 就会动态地完成任务。这意味着 Objective-C 语言不仅需要编译器，还需要 runtime 来执行编译代码。 runtime 是一套用C语言提供的 API，Objective-C 代码最终都会被编译器转化为运行时代码，通过消息机制决定了不同函数调用或转发方式，因此 runtime成为了 Objective-C 作为动态语言使用的基础。 二、runtime 版本runtime 目前共有两个版本， Legacy 与 Modern 版本，与之相对应的编程接口分别是 Objective-C 1.0 与 2.0。Legacy 版本主要用于32位的Mac OS X平台上开发，而 Modern 版本用于 iPhone 程序与 Mac OS X 10.5以及更新版本系统中的64位程序。 两个版本最典型的区别，就是 Modern 版本中若更改类中实例变量的布局，则不必重新编译继承自该类的类。对于 iOS 开发者来说，我们只需要关注 Modern 版本即现行版本的runtime 即可。 三、与 runtime 交互方式接下来会梳理当 NSObject 类与 runtime 交互时，runtime 是如何动态加载新类以及将消息转发给其它对象的。 1.Objective-C 源代码 平时开发中编写的 Objective-C 代码，其背后是 runtime 的运行工作。类、方法、协议等都由 runtime 转化成C语言后用数据结构来定义。 2. Foundation 框架下 NSObject 类的方法 在 iOS 类体系中，绝大部分Objective-C 类继承根类是 NSObject 类（NSProxy类除外，NSProxy定位更适合作为消息转发的代理抽象类），其本身就提供了一些具有动态特性的api。 3. runtime 系统提供的函数 若要直接使用 runtime 提供的函数，必须先引入#import &lt;objc/runtime.h&gt; 通过一个最简单的例子来看下 Objective-C 代码是如何转化成 runtime 的C函数。 四、 消息机制的基本原理与执行流程在上述最简单的Objective-C代码通过 runtime 的C函数转化后，可以发现： 所有的 Objective-C 方法调用都会在编译时转化成C函数 objc_msgSend 的调用 objc_msgSend 方法一定会有两个参数：消息接收者、消息方法名称 runtime 的核心是消息机制，其执行过程大致可分为三个部分：消息发送、动态方法解析、消息转发 编译阶段： 以上全都为不带参数的方法编译后的C函数结构：objc_msgSend(receiver，selector) 带参数的方法被编译成C函数的结构：objc_msgSend(receiver，selector，org1，org2，…) 运行阶段： 在 recevier（消息接收者）寻找对应的 selector（消息方法名称）时， 1. 首先会检测 selector 是否要忽略 2. 其次，检查 receiver 是否为 nil 对象，Objective-C 中是允许一个 nil 对象执行任何一个方法而不会 Crash，究其原因在于会被直接 return 忽略掉 3. 当以上两步没问题后，将开始查找该类的 IMP，默认先从 cache 中寻找，若命中则执行对应的方法 4. 若 cache 中无法命中，则会尝试从方法列表 methodLists 中寻找 5. 若方法列表也未找到，则会到向上查找，从父类的方法列表里寻找，一直找到 NSObject 类为止，正如下图中类关系 此处关于消息发送流程，引用一张已被用烂的类关系图： 6. 若 recevier 最终无法找到对应的 selector ，则执行消息动态解析，由负责动态的添加方法实现 7. 若 receiver 没有实现消息动态解析，则会执行消息重定向，将消息转发给可以处理消息的接收者 8. 若消息转发也没有实现，则会报错消息无法识别、方法找不到错误unrecognzied selector sent to instance并程序 Crash 五、动态解析与消息转发之前让我能够快速理解动态解析与消息转发流程，最常用的，就是对象、类去调用一个未添加 IMP 实现的方法，去查看消息机制转发执行的过程。 借助 runtime 提供的一个消息打印函数extern void instrumentObjcMessageSends(BOOL); 其打印结果会输出到 /private/tmp/msgSend-XXX 图中 testClass 类继承自 NSObject 类，其中 walks 方法只在头文件中进行了声明，但未实现 IMP。 此处需留意一个知识点： 对象方法：存在于与类的实例方法列表中 类方法：存在于元类的实例方法列表中，即类方法是以实例方法的形式存放在元类中 一图胜千言 1. 动态解析当一个对象或类尝试去执行一个未实现 IMP 的方法，消息最终无法正常执行时，会触发 + (BOOL)resolveInstanceMethod:(SEL)sel或+ (BOOL)resolveClassMethod:(SEL)sel 这是系统为我们提供的第一次解决 IMP 未命中机会，可以为对象动态添加 IMP 方法解析。 最终通过runtime中的class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)函数实现。 以下分别是对象实例、类动态解析方法的用法 上述实现动态解析中，若要使其成功执行就必须存在已经实现了的方法，比如上面用到的 对象方法- (void)runInstance和类方法+ (void)run。 关于types参数，即 IMP 函数实现的返回值与参数类型，可以参考官方说明文档Objective-C Runtime Programming Guide 在动态解析方法过程中 对象方法 执行的顺序为 类方法 执行的顺序为 关于消息转发暂且放在一边，在类方法动态解析过程中，发现执行了两次 + (BOOL)resolveClassMethod:(SEL)sel 解析；而在对象方法动态解析过程中，+ (BOOL)resolveInstanceMethod:(SEL)sel方法却只执行了一次。 通过 LLDB 的bt分解每一步，在+ (BOOL)resolveClassMethod:(SEL)sel中添加断点。 两次执行类方法动态解析分析 第一次，上面红色边框中，先执行了方法_objc_msgSend_uncached，然后走方法lookUpImpOrForward，再执行到方法_class_resolveMethod，这个流程其实是寻找 IMP 的过程；若没有找到，就会进入动态解析流程； 第二次，下面红色边框中的信息，发现了消息转发相关方法的执行动作，也就是说第二次时从消息转发过来的，意味着第一次动态解析失败了。在消息转发过来之后，接着会去执行class_getInstanceMethod方法，而这个方法却是实例方法动态解析所用到的。而关于类方法的存放位置，首先它是类的类方法，其次也是元类的实例方法，按照消息执行向上传递的规则，在寻找类方法 IMP 过程中多执行了一次，也就是我们看到的两次类方法动态解析执行。 通过下面这张图可以更好地理解 isa指针在类中向上传递查找顺序，也正好佐证了上述类方法在动态解析过程为什么执行了两次。 isa指针查找顺序图 2. 消息转发当动态解析失败，并没有获取到有效的 IMP 时，系统会做第二次补救措施——消息转发。 消息转发提供了三个方法函数： - (id)forwardingTargetForSelector:(SEL)aSelector - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector - (void)forwardInvocation:(NSInvocation *)anInvocation 当动态解析失败后，进入消息转发流程 首先，会执行函数- (id)forwardingTargetForSelector:(SEL)aSelector。该函数目的在于通过该函数系统会将 SEL 尝试转发给其它对象，而且此对象不能是 self 与 nil。 但该函数返回了 nil 或者 self 时，此时系统会提供最后一次寻找 IMP 的机会。接下来会执行 - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector函数，去询问该消息是否有效，并尝试让其生成一个函数的签名，若签名无效返回 nil 并抛出异常；若不是 nil ，再由函数符号执行器 - (void)forwardInvocation:(NSInvocation *)anInvocation去执行。 当函数生成签名后，系统会尝试执行方法 - (void)forwardInvocation:(NSInvocation *)anInvocation NSInvocation类的对象是调用函数的另一种表现形式，将对象、方法选择器、参数以及返回值等各种信息，都封装到此类的对象中，再通过invoke函数去执行被调用函数，其思想本质是命令者模式的展现。 上述代码中，尝试将此类中的消息转发给了由 testTwo 类创建的对象实例——twoObj 并去执行。 消息转发流程是把未识别的消息分发给了其他不同接收对象，又或者是将所有未识别消息发送给同一个接收对象，其具体实现方式完全可以自由控制。而这一切的前提，是消息接收对象不能有指定方法的实现，才能有机会去执行消息转发。 消息转发小扩展——实现Objective-C 多继承 利用消息转发可以实现 Objective-C 语言编程的多继承效果。两个没有继承关系的类，当一个类执行了未能实现的方法时，可以将该方法转发给另一个可执行该方法的类去执行，这样就可以灵活的弥补 Objective-C 本身不支持多继承的特性，也避免因为层层继承导致类文件结构臃肿、逻辑复杂"},{"title":"iOS12、iOS11、iOS10、iOS9常见适配","date":"2019-03-14T12:51:29.000Z","url":"/14/iOS12%E3%80%81iOS11%E3%80%81iOS10%E3%80%81iOS9%E5%B8%B8%E8%A7%81%E9%80%82%E9%85%8D/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、iOS12（Xcode10）1.1、升级Xcode10后项目报错不允许多个info.plist Xcode10是默认选中的最新的New Build System(Default)，在这个编译系统的环境下，不允许多个info.plist 解决办法一：（推荐） 把build system切换到 Legacy Build System，换言之就是切换成老的编译系统，就OK了。 Xcode-&gt;File-&gt;Project Settings-&gt; Build System -&gt; Legacy Build System. 解决办法二： 删除其他info.plist文件。 iOS 12移除了libstdc++, 用libc++替代 Xcode10中libstdc++相关的3个库(libstdc++、libstdc++.6、libstdc++6.0.9)应该都是被彻底废弃了，如果你使用的三方库中有依赖，请尽快和提供方沟通，告知他们迁移吧。如果自己开发使用，也尽快考虑迁移的事宜吧。 1.2、iPhone XR不支持3D-TouchOC检测代码 swift检测代码 二、iOS11（Xcode9）2.1、安全区域（SafeArea）iOS11为UIViewController和UIView增加了两个新的属性safeAreaInsets和safeAreaLayoutGuide safeAreaInsets 适用于手动计算. safeAreaLayoutGuide 适用于自动布局. 在Storyboard使用Safe Area最低只支持iOS9，iOS8的用户就要放弃了 当UIViewController调用- (void)viewDidLoad时它的所有子视图的safeAreaInsets属性都等于UIEdgeInsetsZero。 viewSafeAreaInsetsDidChange的调用时机如下： 1、viewDidLoad 2、viewWillAppear 3、viewSafeAreaInsetsDidChange 4、viewWillLayoutSubviews 5、viewDidAppear 只有在调用viewSafeAreaInsetsDidChange后，才能获得view以及viewController的SafeArea（UIEdgeInsets）。因此在viewDidload中根据SafeArea设置界面会有问题。 iPhone X：有导航栏的时候可以+44 竖屏 safeAreaInsets &#x3D; (top &#x3D; 44, left &#x3D; 0, bottom &#x3D; 34, right &#x3D; 0) 横屏 safeAreaInsets &#x3D; (top &#x3D; 0, left &#x3D; 44, bottom &#x3D; 21, right &#x3D; 44) 2.2、UIScrollViewiOS 11废弃了UIViewController的automaticallyAdjustsScrollViewInsets属性，新增了contentInsetAdjustmentBehavior属性，所以当超出安全区域时系统自动调整了SafeAreaInsets，进而影响了adjustedContentInset，在iOS11中决定tableView内容与边缘距离的是adjustedContentInset，所以需要设置UIScrollView的contentInsetAdjustmentBehavior属性。 2.3、tableview问题iOS11开始UITableView开启了自动估算行高，estimatedRowHeight estimatedSectionHeaderHeight estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension，如果不实现-tableView: viewForFooterInSection: 和 -tableView: viewForHeaderInSection:，那么estimatedRowHeight estimatedSectionHeaderHeight estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension，导致高度计算不对，会产生空白。解决方法是实现对应方法或吧这三个属性设为0。 2.4、LocalAuthentication 本地认证本地认证框架提供了从具有指定安全策略(密码或生物学特征)的用户请求身份验证的功能。例如，要求用户仅使用Face ID或Touch ID进行身份验证，可使用以下代码： 2.5、启动图的适配方法一：通过LaunchScreen.storyboard方式启动 方法二：使用Assets中的LaunchImage 给Brand Assets添加一张11252436大小的图片 打开Assets.xcassets文件夹，找到Brand Assets 右键Show in Finder 添加一张1125*2436大小的图片 修改Contents.json文件,添加如下内容 2.6、定位相关在 iOS 11 中必须支持 When In Use 授权模式（NSLocationWhenInUseUsageDescription），在 iOS 11 中，为了避免开发者只提供请求 Always 授权模式这种情况，加入此限制，如果不提供When In Use 授权模式，那么 Always 相关授权模式也无法正常使用。 如果要支持老版本，即 iOS 11 以下系统版本，那么建议在 info.plist 中配置所有的 Key 三、iOS10（Xcode8）3.1、(Why？Safe！)插件取消Xcode8取消了三方插件（很多优秀的插件，本来可以显著提高效率）的功能，使用Extension代替 Xcode 8 Extension 推荐 3.2、证书问题为了方便用户来管理，提供Automatically manage signing。需要输入开发者账号！如果没有账号也没关系，在下面也可以选择Debug、Realease、inHouse模式下对应的证书也可以！ 3.3、隐私数据访问问题iOS10，苹果加强了对隐私数据的保护，要对隐私数据权限做一个适配，iOS10调用相机，访问通讯录，访问相册等都要在info.plist中加入权限访问描述，不然之前你们的项目涉及到这些权限的地方就会直接crash掉。 解决办法： 只需要在info.plist添加NSContactsUsageDescription的key, value自己随意填写就可以,这里列举出对应的key(Source Code模式下): 3.4、跳转到app内的隐私数据设置页面iOS 10 干掉了所有系统设置的 URL Scheme，这意味着你再也不可能直接跳转到系统设置页面（比如 WiFi、蜂窝数据、定位等）。 跳转方式 方式一：prefs:root&#x3D;某项服务 适用于 小于 iOS10的系统； NSURL *url &#x3D; [NSURL URLWithString:@”prefs:root&#x3D;WIFI”]; 方式二：prefs:root&#x3D;bundleID 适用于 大于等于iOS8系统，小于iOS10的系统 NSURL *url &#x3D; [NSURL URLWithString:@”prefs:root&#x3D;bundleID”]; 方式三：UIApplicationOpenSettingsURLString 适用于 大于等于iOS8的系统 NSURL *url &#x3D; [NSURL URLWithString:UIApplicationOpenSettingsURLString]; 跳转目的地 iOS系统版本 &lt;&#x3D; iOS7 , 只能跳转到 系统设置页面 iOS系统版本 &gt;&#x3D; iOS8 ，支持跳转到第三方应用的设置界面中。使用prefs:root&#x3D;bundleID ,bundleID是你第三方应用工程的唯一ID iOS系统版本 &gt;&#x3D; iOS10，支持跳转到自己应用设置，不支持跳转到系统设置 3.5、字体变化苹果的默认字体会随着iOS系统版本的不同而不同，iOS10中字体变大了。导致了原来的显示有问题，会造成…的出现。暂时没有好的解决办法，需要自己在一个个适配一下！ 3.6、UICollectionViewCell的的优化在iOS 10 之前,cell只能从重用队列里面取出,再走一遍生命周期,并调用cellForItemAtIndexPath创建或者生成一个cell. 在iOS 10 中,系统会cell保存一段时间,也就是说当用户把cell滑出屏幕以后,如果又滑动回来,cell不用再走一遍生命周期了,只需要调用willDisplayCell方法就可以重新出现在屏幕中了. iOS 10 中,系统是一个一个加载cell的,二以前是一行一行加载的,这样就可以提升很多性能; iOS 10 新增加的Pre-Fetching预加载 3.7、UIRefreshControl在iOS 10 中, UIRefreshControl可以直接在UICollectionView和UITableView中使用,并且脱离了UITableViewController.现在RefreshControl是UIScrollView的一个属性. 3.8、UserNotifications(用户通知)iOS 10所有相关通知被统一到了UserNotifications.framework框架中。增加了撤销、更新、中途还可以修改通知的内容。通知不在是简单的文本了，可以加入视频、图片，自定义通知的展示等等。 iOS 10相对之前的通知来说更加好用易于管理，并且进行了大规模优化，对于开发者来说是一件好事。 iOS 10开始对于权限问题进行了优化，申请权限就比较简单了(本地与远程通知集成在一个方法中)。 四、iOS9（Xcode7）4.1、BitcodeXcode7 默认启用 Bitcode，但是如果我们用到的第三方库编译时还没启用 Bitcode，主工程就会编译不过。Bitcode 是苹果 App Thinning 的机制之一，可以减少安装包的大小。App store 会将这个 Bitcode 编译为可执行的64位或32位程序。 解决办法一： 最简单的解决办法是先把 Bitcode 关掉：把 Build settings - Build Options - Enable Bitcode 改为 NO。image.png 解决办法二： 移除不支持BitCode的平台SDK，或者寻找支持BitCode的替代品，或者联系SDK方支持BitCode。 4.2、HTTP 请求失败iOS9 默认不支持 HTTP 请求，需要改用更安全的 HTTPS（默认用 TLS 1.2）。苹果还提供了配置，使得所有安全性更低的网络请求也能使用，解决方案就是在 info.plist 里面增加以下配置： 如果复杂一些，还可以指定白名单域名，声明所支持 TLS 的最低版本。另外需要注意的是，即使写了上述配置，在 HTTPS 页面中，HTTP 的 javascript 或 css 不会被加载，因为苹果认为这降低了页面的安全性。 4.3、canOpenUrl 限制canOpenUrl 可以用来判断用户是否安装了某个 APP。也许是出于用户隐私的考虑，iOS9 上对 canOpenUrl 做了限制，最多只能对 50 个 scheme 做判断。如果是用 Xcode7 编译，需要在 plist 里面声明这些 scheme，没有声明的会直接返回 NO： 4.4、UIStatusBar的问题iOS9中废弃的方法 "},{"title":"iOS开发微信SDK的集成（分享、支付）","date":"2019-01-20T13:52:56.000Z","url":"/20/iOS%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1SDK%E7%9A%84%E9%9B%86%E6%88%90%EF%BC%88%E5%88%86%E4%BA%AB%E3%80%81%E6%94%AF%E4%BB%98%EF%BC%89/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"在我们的App中是很经常的会用到微信的两个功能，1就是分享，2就是支付（通常会和支付宝、银联支付放在一起使用),通常接入这种三方的东西，对于移动端来说，过程都比较简单，但是对于后台来说，一般也不是说难，就是步骤多，配置的东西比移动端多（像比如支付过程）, 废话不多说，由于我这里的分享只需要做微信的分享，所以过程比较简单，配置什么的就不多说了，自己去看微信支付的UML流程图和微信SDK的配置流程，对于iOS端的代码如下:首先在工程里面配置白名单： AppDelegate里面初始化微信SDK： 支付or分享代码： 支付or分享结果的回调： 集成起来比较简单，由于这里的支付请求加密参数是放在后台进行的（也理论上是后台做比较安全，为了防止反编译，一般是后台做）App端做的事情相对来来说还是比较少的。"},{"title":"MD5加密原理解析","date":"2019-01-07T05:43:50.000Z","url":"/07/MD5%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","tags":[["加密","/tags/%E5%8A%A0%E5%AF%86/"]],"categories":[["加密技术","/categories/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"]],"content":"一、MD5算法基础概念​ MD5算法是Hash算法的一种，叫做讯息摘要演算法。所谓摘要，从字面意思理解，是指内容的大概。在MD5算法中，这个摘要是指将任意数据映射成一个128位长的摘要信息。并且其是不可逆的，即从摘要信息无法反向推演中原文，在演算过程中，原文的内容也是有丢失的。 ​ 因为MD5算法最终生成的是一个128位长的数据，从原理上说，有2^128种可能，这是一个非常巨大的数据，约等于3.4乘10的38次方，虽然这个是个天文数字，但是世界上可以进行加密的数据原则上说是无限的，因此是可能存在不同的内容经过MD5加密后得到同样的摘要信息，但这个碰中的概率非常小。 二、MD5的使用场景​ MD5常用在密码加密中，一般为了保证用户密码的安全，在数据库中存储的都是用户的密码经过MD5加密后的值，在客户端用户输入密码后，也会使用MD5进行加密，这样即使用户的网络被窃听，窃听者依然无法拿到用户的原始密码，并且即使用户数据库被盗，没有存储明文的密码对用户来说也多了一层安全保障。 ​ MD5签名技术还常用于防止信息的篡改。使用MD5可以对进行进行签名，接收者拿到信息后只要重新计算签名和原始签名进行对比，即可知道数据信息是否中途被篡改了。 三、MD5算法原理​ MD5算法大致分为4步完成： 第1步：进行数据填充整理 ​ 这一步是对要加密的数据进行填充和整理，将要加密的二进制数据对512取模，得到的结果如果不够448位，则进行补足，补足的方式是第1位填充1，后面全部填充0。 第2步：记录数据长度 ​ 经过第一步整理完成后的数据的位数可以表示为N*512+448，再向其后追加64位用来存储数据的长度，比如数据的长度为16字节，则用10000来填充后64位。这一步做完后，数据的位数将变成(N+1)*512。 第3步：以标准的幻数作为输入 ​ MD5的实现需要每512个字节进行一次处理，后一次处理的输入为前一次处理的输出，因此，在循环处理开始之前，需要拿4个标准数作为输入，它们分别是： 第4步：进行N轮循环处理，将最后的结果输出 ​ 这一步重要的是每一轮的处理算法，每一轮处理也要循环64次，这64次循环被分为4各组，每16次循环为一组，每组循环使用不同的逻辑处理函数，处理完成后，将输出作为输入进入下一轮循环。 四、MD5核心算法的实现这里演示的是每轮循环的核心算法： 首先进行3个函数的声明： MD5算法中处理的数据都是小端字节序的，而使用Objective-C处理的NSData对象的字节序是大端字节序，因此我们需要做一下转换。函数实现如下： 在MD5中有需要对字节数据进行循环左移的操作，循环左移函数实现如下： 下面是MD5函数的核心实现： "},{"title":"消息传递的方式","date":"2018-12-10T12:11:28.000Z","url":"/10/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1.KVC实现原理 KVC，键-值编码，使用字符串直接访问对象的属性。 底层实现，当一个对象调用setValue方法时，方法内部会做以下操作： 1.检查是否存在相应key的set方法，如果存在，就调用set方法 2.如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值 3.如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值 4.如果还没找到，则调用valueForUndefinedKey：和setValue：forUndefinedKey：方法 2.KVO的实现原理 KVO-键值观察机制，原理如下： 1.当给A类添加KVO的时候，runtime动态的生成了一个子类NSKVONotifying_A，让A类的isa指针指向NSKVONotifying_A类，重写class方法，隐藏对象真实类信息 2.重写监听属性的setter方法，在setter方法内部调用了Foundation 的 _NSSetObjectValueAndNotify 函数 3._NSSetObjectValueAndNotify函数内部 a) 首先会调用 willChangeValueForKey b) 然后给属性赋值 c) 最后调用 didChangeValueForKey d) 最后调用 observer 的 observeValueForKeyPath 去告诉监听器属性值发生了改变 . 4.重写了dealloc做一些 KVO 内存释放 3.如何手动触发KVO方法 手动调用willChangeValueForKey和didChangeValueForKey方法 键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangeValueForKey。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， didChangeValueForKey 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了 有人可能会问只调用didChangeValueForKey方法可以触发KVO方法，其实是不能的，因为willChangeValueForKey: 记录旧的值，如果不记录旧的值，那就没有改变一说了 4.通知和代理有什么区别 通知是观察者模式，适合一对多的场景 代理模式适合一对一的反向传值 通知耦合度低，代理的耦合度高 5.block和delegate的区别 delegate运行成本低，block的运行成本高 block出栈需要将使用的数据从栈内存拷贝到堆内存，当然对象的话就是加计数，使用完或者block置nil后才消除。delegate只是保存了一个对象指针，直接回调，没有额外消耗。就像C的函数指针，只多做了一个查表动作。 delegate更适用于多个回调方法（3个以上），block则适用于1，2个回调时。 6.为什么Block用copy关键字Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。"},{"title":"数据安全及加密","date":"2018-11-23T12:58:15.000Z","url":"/23/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%8F%8A%E5%8A%A0%E5%AF%86/","categories":[["加密技术","/categories/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"]],"content":"1.对称加密和非对称加密的区别？ 1、对称加密又称公开密钥加密，加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 2、非对称加密又称共享密钥加密，使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。 2.简述 SSL 加密的过程用了哪些加密方法，为何这么做？SSL 加密，在过程中实际使用了 对称加密 和 非对称加密 的结合。主要的考虑是先使用 非对称加密 进行连接，这样做是为了避免中间人攻击秘钥被劫持，但是 非对称加密 的效率比较低。所以一旦建立了安全的连接之后，就可以使用轻量的 对称加密。 3.iOS的签名机制是怎么样的 签名机制： 先将应用内容通过摘要算法，得到摘要 再用私钥对摘要进行加密得到密文 将源文本、密文、和私钥对应的公钥一并发布 验证流程： 查看公钥是否是私钥方的 然后用公钥对密文进行解密得到摘要 将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常 "},{"title":"iOS 设置圆角、指定位置圆角","date":"2018-10-23T12:59:50.000Z","url":"/23/iOS%20%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E3%80%81%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E5%9C%86%E8%A7%92/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1. 使用UIView.layer.cornerRadius 进行圆角设置 此处view.layer. masksToBounds = YES; 会触发离屏渲染，如果在UITableViewCell和UICollectionViewCell中使用，严重的会掉帧、不流畅 2.使用贝塞尔曲线画圆角及指定位置圆角 UIRectCorner 的定义如下 UIRectCorner 可以使用位运算进行圆角设置，如： 圆角加边框 3.iOS11 新特性——改善view圆角 CACornerMask的定义如下： 4.对UIView进行自定义圆角分类 此方法在iOS 11 中使用iOS 11中的maskedCorners进行圆角设置，如是iOS 11 以下则使用贝塞尔曲线画圆角。"},{"title":"调试技巧","date":"2018-09-23T11:59:50.000Z","url":"/23/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1.LLDB常用的调试命令？ po：print object的缩写，表示显示对象的文本描述，如果对象不存在则打印nil。 p：可以用来打印基本数据类型。 call：执行一段代码 如：call NSLog(@”%@”, @”yang”) expr：动态执行指定表达式 bt：打印当前线程堆栈信息 （bt all 打印所有线程堆栈信息） image：常用来寻找栈地址对应代码位置 如：image lookup –address 0xxxx 2.断点调试 条件断点 打上断点之后，对断点进行编辑，设置相应过滤条件。下面简单的介绍一下条件设置： Condition：返回一个布尔值，当布尔值为真触发断点，一般里面我们可以写一个表达式。 Ignore：忽略前N次断点，到N+1次再触发断点。 Action：断点触发事件，分为六种： AppleScript：执行脚本。 Capture GPU Frame：用于OpenGL ES调试，捕获断点处GPU当前绘制帧。 Debugger Command：和控制台中输入LLDB调试命令一致。 Log Message：输出自定义格式信息至控制台。 Shell Command：接收命令文件及相应参数列表，Shell Command是异步执行的，只有勾选“Wait until done”才会等待Shell命令执行完在执行调试。 Sound：断点触发时播放声音。 Options(Automatically continue after evaluating actions选项)：选中后，表示断点不会终止程序的运行。 异常断点 异常断点可以快速定位不满足特定条件的异常，比如常见的数组越界，这时候很难通过异常信息定位到错误所在位置。这个时候异常断点就可以发挥作用了。 Exception：可以选择抛出异常对象类型：OC或C++。 Break：选择断点接收的抛出异常来源是Throw还是Catch语句。 符号断点 符号断点的创建方式和异常断点一样一样的，在符号断点中可以指定要中断执行的方法： Symbol:[类名 方法名]可以执行到指定类的指定方法中开始断点。 3.iOS 常见的崩溃类型有哪些？ unrecognized selector crash KVO crash NSNotification crash NSTimer crash Container crash NSString crash Bad Access crash （野指针） UI not on Main Thread Crash "},{"title":"CALayer 绘图层","date":"2018-09-13T05:42:06.000Z","url":"/13/CALayer-%E7%BB%98%E5%9B%BE%E5%B1%82/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":" CALayer 绘图层 在 iOS 系统中，你能看得见摸得着的东西基本上都是 UIView，比如一个按钮、一个文本标签、一个文本输入框、一个图标等等，这些都是 UIView。其实 UIView 之所以能显示在屏幕上，完全是因为它内部的一个层。 1、CALayer 绘图层 在 iOS 系统中，你能看得见摸得着的东西基本上都是 UIView，比如一个按钮、一个文本标签、一个文本输入框、一个图标等等，这些都是 UIView。其实 UIView 之所以能显示在屏幕上，完全是因为它内部的一个层。在创建 UIView 对象时，UIView 内部会自动创建一个层（即 CALayer 对象），通过 UIView 的 layer 属性可以访问这个层。当 UIView 需要显示到屏幕上时，会调用 drawRect: 方法进行绘图，并且会将所有内容绘制在自己的层上，绘图完毕后，系统会将层拷贝到屏幕上，于是就完成了 UIView 的显示。换句话说，UIView 本身不具备显示的功能，是它内部的层才有显示功能。 CALayer 的简单使用 CALayer 是被定义在 QuartzCore 框架中的，通过操作 CALayer 对象，可以很方便地调整 UIView 的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。 2、基本绘图层属性设置 1、设置阴影 2、圆角半径 3、边框 4、imageView 圆角半径设置 3、形变属性设置3.1 视图形变 1、单一形变 效果 2、 叠加形变 效果 3、累加形变 效果 4、还原形变 3.2 绘图层形变 1、单一形变 效果 2、快速进行绘图层形变，KVC 效果 3、绘图层 3D 形变 效果 3.3 获取形变值 获取旋转的角度 4、创建新的绘图层 UIView 内部默认有个 CALayer 对象（层），通过 layer 属性可以访问这个层。要注意的是，这个默认的层不允许重新创建，但可以往层里面添加子层。UIView 可以通过 addSubview: 方法添加子视图，类似地，CALayer 可以通过 addSublayer: 方法添加子层。 1、添加一个简单的图层 效果 2、添加一个显示图片的图层 效果 3、为什么 CALayer 中使用 CGColorRef 和 CGImageRef 这 2 种数据类型，而不用 UIColor 和 UIImage ？ 首先要知道：CALayer 是定义在 QuartzCore 框架中的；CGImageRef、CGColorRef 两种数据类型是定义在 CoreGraphics 框架中的；UIColor、UIImage 是定义在 UIKit 框架中的。 其次，QuartzCore 框架和 CoreGraphics 框架是可以跨平台使用的，在 iOS 和 Mac OS X 上都能使用，但是 UIKit 只能在 iOS 中使用。 因此，为了保证可移植性，QuartzCore 不能使用 UIImage、UIColor，只能使用 CGImageRef、CGColorRef。 不过很多情况下，可以通过 UIKit 对象的特定方法，得到 CoreGraphics 对象，比如 UIImage 的 CGImage 方法可以返回一个 CGImageRef。 4、UIView 和 CALayer 的选择 细心的朋友不难发现，其实前面的 2 个效果不仅可以通过添加层来实现，还可以通过添加 UIView 来实现。比如，第 1 个红色的层可以用一个 UIView 来实现，第 2 个显示图片的层可以用一个 UIImageView 来实现。既然 CALayer 和 UIView 都能实现相同的显示效果，那究竟该选择谁好呢？ 其实，对比 CALayer，UIView 多了一个事件处理的功能。也就是说，CALayer 不能处理用户的触摸事件，而 UIView 可以。 所以，如果显示出来的东西需要跟用户进行交互的话，用 UIView；如果不需要跟用户进行交互，用 UIView 或者 CALayer 都可以。 当然，CALayer 的性能会高一些，因为它少了事件处理的功能，更加轻量级。 5、UIView 和 CALayer 的关系 UIView 可以通过 subviews 属性访问所有的子视图，类似地，CALayer 也可以通过 sublayers 属性访问所有的子层。 UIView 可以通过 superview 属性访问父视图，类似地，CALayer 也可以通过 superlayer 属性访问父层。 下面再看一张 UIView 和 CALayer 的关系图，如果两个 UIView 是父子关系，那么它们内部的 CALayer 也是父子关系。 5、绘图层隐式动画属性 在前面已经提到，每一个 UIView 内部都默认关联着一个 CALayer，我们可称这个 Layer 为 Root Layer（根层）。所有的非 Root Layer，也就是手动创建的 CALayer 对象，都存在着隐式动画。 当对非 Root Layer 的部分属性进行相应的修改时，默认会自动产生一些动画效果，这些属性称为 Animatable Properties 可动画属性。 列举几个常见的 Animatable Properties： 1、隐式动画属性设置 效果 2、可以通过动画事务（CATransaction）关闭默认的隐式动画效果。 6、绘图层 position 和 anchorPoint 属性 position 和 anchorPoint 属性都是 CGPoint 类型的。 1、anchorPoint 为默认值（0.5, 0.5） 设置了 myLayer 的 position 为（100, 100），又因为 anchorPoint 默认是（0.5, 0.5），所以最后的效果是 myLayer 的中点会在父层的（100, 100）位置。 2、anchorPoint 为（0, 0） 若将 anchorPoint 改为（0, 0），myLayer 的左上角会在（100, 100）位置。 3、anchorPoint 为（1, 1） 若将 anchorPoint 改为（1, 1），myLayer 的右下角会在（100, 100）位置。 4、anchorPoint 为（0, 1） 将 anchorPoint 改为（0, 1），myLayer 的左下角会在（100, 100）位置。 7、自定义绘图层7.1 自定义绘图层方法 1 创建一个 CALayer 的子类，然后覆盖 drawInContext: 方法，使用 Quartz2D API 进行绘图。 QCLayer.h QCLayer.m ViewController.m 效果 7.2 自定义绘图层方法 2 设置 CALayer 的 delegate，然后让 delegate 实现 drawLayer:inContext: 方法，当 CALayer 需要绘图时，会调用 delegate 的 drawLayer:inContext: 方法进行绘图。 这里要注意的是：不能再将某个 UIView 设置为 CALayer 的 delegate，因为 UIView 对象已经是它内部根层的 delegate，再次设置为其他层的 delegate 就会出问题。UIView 和它内部 CALayer 的默认关系图： 创建新的层，设置 delegate，然后添加到控制器的 view 的 layer 中。 让 CALayer 的 delegate（前面设置的是控制器）实现 drawLayer:inContext: 方法 效果 7.3 UIView 的详细显示过程 当 UIView 需要显示时，它内部的层会准备好一个 CGContextRef（图形上下文），然后调用 delegate（这里就是 UIView）的 drawLayer:inContext: 方法，并且传入已经准备好的 CGContextRef 对象。而 UIView 在 drawLayer:inContext: 方法中又会调用自己的 drawRect: 方法 平时在 drawRect: 中通过 UIGraphicsGetCurrentContext() 获取的就是由层传入的 CGContextRef 对象，在 drawRect: 中完成的所有绘图都会填入层的 CGContextRef 中，然后被拷贝至屏幕。 8、渐变图层 渐变图层 CAGradientLayer : CALayer 添加渐变图层 效果 9、复制图层 复制图层 CAReplicatorLayer : CALayer，可以把图层里面所有子层复制 添加复制图层 效果 "},{"title":"Cocoapods使用教程","date":"2018-08-23T03:14:10.000Z","url":"/23/Cocoapods%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","tags":[["Cocoapods","/tags/Cocoapods/"]],"categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"一、进项项目文件中用xcode创建一个project，已经创建过的话，用终端进入这个project.我用Xcode创建的CcocoaPodsDemo放在桌面，现在输入指令进入这个project中： 二、在项目中创建一个Podfile文件 查看一下文件里面有没有这个文件 三、编辑Podfile文件双击进入Podfile文件,编辑一下Podfile 编辑完PodFile保存一下，在终端执行一下 四、CocoaPods常用语法解释指定特定CocoaPodsDemo的依赖库 指定了开源库应该被编译在哪个平台以及平台的最低版本 若不指定平台版本，官方文档里写明各平台默认值为iOS：4.3,OS X：10.6,tvOS：9.0,watchOS：2.0 屏蔽cocoapods库里面的所有警告 明确指定继承于父层的所有pod，默认就是继承的 使用frameworks动态库替换静态库链接 屏蔽制定YYMOdel库里面的警告 指定项目空间名字，默认就是项目的名字 指定工程文件名，默认就是项目的名字 指定继承于父层的所有pod，默认就是继承的 一个podspec能够从外部的仓库源的获取 五、第三方库更新执行 pod repo update更新本地仓库,作用类似pod setup。 不过这个命令经常不单独调用。比如执行pod setup、pod search、pod install、pod update会默认执行pod repo update 把Podfile内全部的库更新重新安装 该命令只安装新添加的库，已更新的库忽略（推荐这种比较速度比较快一点） 安装开源库之前, 不会执行pod repo update指令 所有第三方到最新版本 更新指定的库更新到最新版本，其它库忽略 安装开源库之前, 不会执行pod repo update指令 六、生成的文件 Podfile文件：项目的第三方库的依赖以及项目的基本配置 Podfile.lock文件:最后一次更新Pods时, 保存所有第三方框架的版本号 xxx.xcworkspace文件:重新生成一个工作空间，打开这个工程文件来进行开发 pods目录:保存通过pod install 或者 pod update下载下来的第三方开源库的源代码 总结CocoaPods还是要多实践，多操作。体验管理第三方库的便利"},{"title":"ReactiveCocoa常用方法","date":"2018-07-21T07:50:25.000Z","url":"/21/ReactiveCocoa%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","tags":[["开源框架","/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1、RACSignal使用： 2、RACSubject当做代理使用 3、RACSequence和RACTuple结合使用遍历字典和数组 4、RACCommand 5、其余常见用法 6、常见宏"},{"title":"Swift与Objective-C混编","date":"2018-05-22T13:32:56.000Z","url":"/22/Swift%E4%B8%8EObjective-C%E6%B7%B7%E7%BC%96/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1、swift 项目 中调用oc当你在一个swift项目中引入oc文件时，xcode会提示你是否自动创建桥连接文件： 如果你用系统自动生成，只需要将要使用到的oc的文件导入到桥连接文件中，然后可以使用swift直接使用oc的文件； 如果你没有选择系统生成，那你可以手动创建桥连接文件，桥连接文件格式必须为：项目名-Bridging-Header.h 将桥连接文件路径 Build Setting -OC bridging Header将桥连接文件路径填入 在桥连接文件中导入你要使用的oc文件 然后按照swift语言去使用oc即可 如果你想在swift项目中的oc文件中再 调用swift： 1）首先把Build Setting -&gt; Packaging -&gt; Define Modules 设为YES 确认Product Module Name 就是项目名称 系统会自动生成一个 项目名-Swift.h 文件，这个文件你是看不到的，它的用途就是可以使用swift文件，你只需要在你需要使用swift的oc文件中去导入他，你不需要在oc文件中导入桥连接，这和oc调swift两回事 swift 使用oc 中的某些方法时，比如oc 中自定义的分类，方法名会被优化 例如你有一个计算label高度的oc 分类方法： 在swift 中使用是这样 2、oc项目中调用swift当你添加swift文件时，xcode会提示你是否自动创建桥连接文件，如果你选择否，如果你还想在swft文件中去调用oc就需要手动去创建桥连接文件，你要明白，桥连接文件是swift去调用oc需要的。 oc 中调用swift需要： 1）首先把Build Setting -&gt; Packaging -&gt; Define Modules 设为YES 2）确认Product Module Name 就是项目名称 3）系统会自动生成一个 项目名-Swift.h 文件，这个文件你是看不到的，你只需要在需要使用swift的oc文件中导入 项目名-Swift.h 文件即可，这个 项目名-Swift.h 文件作用就是告诉oc文件内可以去使用所有的swift文件。 3、oc 中调用swift,注意点：如果你只想暴露个别的属性和方法给 Objective-C 访问和调用，你只需要在要暴露的属性和方法前添加 @objc 关键字即可 3.1 oc 调用swift中的类 被调用的swift类必须继承于NSObject或其子类 如果你只是想用swift中类的某几个属性和方法，那在相应 属性和方法前加@objc修饰符； 如果你想使用类中的所有属性和方法，那你需要在这个类之前加@objcMembers 我们可以得出结论，@objc 与 @objcMembers 的关键区别在于暴露给 Objective-C 的属性、方法的范围。如果我们想要保护业务实现的细节，就需要合理的使用 @objc 与 @objcMembers 关键字。 3.2 oc 调用swift 中枚举 oc 中的枚举只有Int类型，所以要调用的枚举也必须是Int 类型: 在枚举定义前面加上@objc 3.3 oc 使用swift 中的协议，协议定义前加上@objc即可 3.4 oc 是无法使用swift中的结构体的如果想得到结构体中的值，也只能写个方法返回相应值了 3.5 在 OC 项目中使用基于 Swift 的 CocoaPods 库 Podfile 要用 CocoaPods，首先要修改的当然是 Podfile，这是最简单的一步，只需要在文件开始加上这一句： use_frameworks! 这是告诉 CocoaPods：“请把我要用到的第三方库用动态框架的形式集成进来”。因为 Apple 不允许开发者构建内含 Swift 代码的静态库，所以要往 OC 项目中集成第三方 Swift 代码的时候就只能通过动态框架（ framework ）的形式了。 最后注意点： 1）oc 不能去swift中使用oc不存在的类型，比如可选类型 oc 的控制器是不能继承swift中的控制器，swift控制器可以继承oc的控制器。 3） 混编期间报错，不要怀疑自己代码，先编译一下再下结论"},{"title":"Swift基础语法（五）","date":"2018-04-12T13:02:55.000Z","url":"/12/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89/","tags":[["Swift","/tags/Swift/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、纯代码创建应用根试图 二、UILabel、UIButton、UIImageView的使用 三、UITableView的使用 在Swift中，创建tableViewCell的方法可以分为两种创建tableView时候注册和需要使用时手动创建。先聊聊创建tableView的时候直接注册cell： 当注册了Cell之后，在没有可重用的Cell时会自动创建，并且不能在需要时手动创建。 可以在自定义cell中处理点击状态下的显示 四、UITabBarController的使用 这里特别说明下：默认未选中标签的图片和文字是灰色的，选中的是蓝色的，下面修改成橙色： 如何显示原始图片的颜色和图案？ .imageWithRenderingMode(.AlwaysOriginal) 即可。 五、单例 六、从相册选择照片或者拍照"},{"title":"Swift基础语法（四）","date":"2018-03-23T12:10:45.000Z","url":"/23/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89/","tags":[["Swift","/tags/Swift/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、闭包Swift 中闭包的概念就像是Objective-C中的block。OC中的block类似于匿名函数，闭包是用来定义函数， 同时闭包可以嵌套和作为参数传递。 在 Swift 中，函数也只不过是一种特殊的闭包。Swift 中的闭包有很多优化的地方： 各种格式下的闭包 @noescape 和 @escaping 简单的介绍就是如果这个闭包是在这个函数结束前内被调用，就是非逃逸的即noescape。如果这个闭包是在函数执行完后才被调用，调用的地方超过了这函数的范围，所以叫逃逸闭包。 举个例子就是我们常用的masonry或者snapkit的添加约束的方法就是非逃逸的。因为这闭包马上就执行了。网络请求请求结束后的回调的闭包则是逃逸的，因为发起请求后过了一段时间后这个闭包才执行。比如这个Alamofire里的处理返回json的completionHandler闭包，就是逃逸的。 定义闭包属性的问题 闭包的循环引用问题 二、代理流程基本和OC中的一致 三、通知流程基本和OC中的一致 四、构造函数普通构造函数 构造函数-KVC构造 在swift 4.0中使用系统方法setValuesForKeys()进行赋值，明明有这个属性，但它还是走override func setValue(_ value: Any?, forUndefinedKey key: String)这个未定义的方法原因是：swift 4.0 版本要在属性前面加@objc 五、懒加载格式：lazy var 变量: 类型 &#x3D; { 创建变量代码 }()懒加载的写法本质上是定义并执行一个闭包 六、重写属性的Set、get发方法"},{"title":"Swift基础语法（三）","date":"2018-03-22T03:32:55.000Z","url":"/22/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89/","tags":[["Swift","/tags/Swift/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、字符串在OC中字符串类型时NSString，在Swift中字符串类型是String OC中字符串@””，Swift中字符串”” 遍历字符串 字符串拼接 字符串的截取 字符串的判断 ASC 值进行比较 二、数组数组（Array）是一串有序的由相同类型元素构成的集合数组分成：可变数组和不可变数组 使用let修饰的数组是不可变数组 使用var修饰的数组是可变数组 对数组的基本操作 数组的遍历 数组的合并 Swift中关于数组的 Sorted、forEach、 Map,Flatmap,Filter,Reduce的用法简化参数名，如$0，$1(从0开始，表示第i个参数…) Sorted forEach Map FlatMap Filter reduce 三、字典字典允许按照某个键来访问元素字典是由两部分集合构成的，一个是键（key）集合，一个是值（value）集合键集合是不能有重复元素的，而值集合是可以重复的，键和值是成对出现的Swift字典类型是Dictionary，也是一个泛型集合。 字典的初始化- 使用let修饰的数组是不可变字典- 使用var修饰的数组是可变字典 字典的基本操作 字典的遍历 字典的合并 四、方法的书写方法调用 闭包中必须使用 self，类中使用时不必加self 有参数、无返回值： 无参数、有一个返回值： 无参数、有二个返回值： 有若干个不确定的参数、有一个返回值： 函数的外部参数 五、访问修饰符在Swift语言中，目前有五种修饰符，有 open public internal fileprivate private 这五个访问权限，都可以修饰属性和方法。 5种修饰符访问权限排序 open&gt;public&gt;internal&gt;fileprivate&gt;private "},{"title":"Swift基础语法（二）","date":"2018-03-17T12:10:45.000Z","url":"/17/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["Swift","/tags/Swift/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、常量&amp;变量 二、Swift中数据类型Swift中的数据类型也有:整型&#x2F;浮点型&#x2F;对象类型&#x2F;结构体&#x2F;元组类型等等先了解整型和浮点型 1、整型 有符号 无符号 2、浮点型 3、Swift中在进行基本运算时必须保证类型一致,否则会出错 相同类型之间才可以进行运算 因为Swift中没有隐式转换 4、数据类型的转化 Int类型转成Double类型:Double(标识符) Double类型转成Int类型:Int(标识符) 5、元组元组是Swift中特有的,OC中没有元组相关类型。 三、逻辑分支1、if分支语句判断句可以不加() 2、三目运算符Swift 中的 三目 运算保持了和 OC 一致的风格 3、guard的使用guard是Swift2.0新增的语法它与if语句非常类似，它设计的目的是提高程序的可读性guard语句必须带有else语句，它的语法如下： 当条件表达式为true时候跳过else语句中的内容，执行语句组内容 条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw 4、switch分支基本用法和OC用法一致不同之处:switch后可以不跟()case后可以不跟break(默认会有break) 一个case判断中,可以判断多个值 多个值以 , 隔开 Switch支持多种数据类型浮点型的switch判断支持字符串类型判断switch支持区间判断 开区间:0..&lt;10 表示:0~9,不包括10 闭区间:0…10 表示:0~10 四、循环for in 循环和 下标遍历循环 如果在for循环中不需要用到下标i while循环 while的判断句必须有正确的真假,没有非0即真 while后面的()可以省略 do while循环使用repeat关键字来代替了do "},{"title":"Swift基础语法（一）","date":"2018-03-10T13:32:34.000Z","url":"/10/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["Swift","/tags/Swift/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"Swift的语法特点从它的语法中能看到Objective-C、JavaScript、C#、Python等语言的影子。其借鉴了Objective-C、JavaScript、C#、Python等语言的优点。同时具备编译型语言的高性能和脚本语言的灵活交互性。 编译型语言：就是要保证我们所写的代码全部编译通过，程序才能执行； 脚本语言：你写的代码对一行执行一行，比如你写了10行，第9行有Bug，那么前8行是可以执行成功的 Swift和其它编程语言相比有哪些变化？ 1、没有main函数，其它编程语言认为mian函数是程序的入口，Swift认为程序是从上往下一行一行执行的， 因此第一行代码就是程序入口。2、语句结束时不需要加”;”，当然若你喜欢也是可以加”;”3、如果同一行有多个语句，则依然需要加”;”，不建议一行写多条语句。4、定义标识符时必须声明该标识符是变量还是常量。5、声明标识符的格式：变量&#x2F;常量关键字 名称:数据类型 （当然你也可以不写数据类型，Swift会自动根据初始值确定其类型），示例如下： 6、( )表示初始化也可以表示执行7、在swift中默认所有的文件共享所有的对象的方法也是默认可以调用8、命名空间: 在同一个项目下叫做命名空间，在同一个命名空间下所有的文件共享9、swift 属性默认都是强引用的10、swift中 init 方法就是构造方法,并且所有的构造方法都叫 init11、在Swift中，运算符不能直接跟在变量或常量的后面。 Swift中的！和 ？的用法总结 Swift语言使用var定义变量，但和别的语言不同，Swift里不会自动给变量赋初始值，也就是说变量不会有默认值，所以要求使用变量之前必须要对其初始化。如果在使用变量之前不进行初始化就会报错： Optional其实是一个enum枚举值，它有两个值：None和Some。Optional.None其实就是nil，Optional.Some就是非nil，它会通过Some(T)来进行Wrap包装原始值，这也是为啥使用Optional类型的时候要进行拆包unWrap（从enum中读取原始值）了。 声明为Optional只需要在类型后面紧跟一个?或者！即可 如: 那么我们怎么使用Optional可选类型的值呢？直接在后面加上一个？号即可。如果是nil值，也就是Optional.None，会跳过后面的操作不执行，如果有值，也就是Optional.Some，就会进行unWrap拆包操作，比如： 问号？a.声明时添加？，告诉编译器这个是Optional的，如果声明时没有手动初始化，就自动初始化为nil。b.在对变量值操作前添加？，判断如果变量时nil，则不响应后面的方法。 叹号！a.声明时添加！，告诉编译器这个是Optional的，并且之后对该变量操作的时候，都隐式的在操作前添加！b.在对变量操作前添加！，表示默认为非nil，直接解包进行处理。不小心让改变量为nil，程序就会crash掉。 swift 中 as as! as? 区别**（1） as **仅当一个值的类型在运行时（runtime）和as模式右边的指定类型一致、或者是该类型的子类 的情况下，才会匹配这个值。如果匹配成功，被匹配的值的类型被转换成as模式左边指定的模式。 （2） as！ （3） as？"},{"title":"Swift和Objective-C的优缺点对比","date":"2018-03-01T13:00:29.000Z","url":"/01/Swift%E5%92%8CObjective-C%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"Swift和Objective-C的联系**Swift和Objective-C共用一套运行时环境，Swift的类型可以桥接到Objective-C**（下面我简称OC），反之亦然 其次就是，OC之前的积累的很多类库，在Swift中大部分依然可以直接使用，当然，Swift3之后，一些语法改变了很多，不过还是有迹可循的。OC出现过的绝大多数概念，比如引用计数、ARC、属性、协议、接口、初始化、扩展类、命名参数、block等，在Swift中继续有效（可能最多换个术语）。Swift大多数概念与OC一样。当然Swift也多出了一些新兴概念，这些在OC中是没有的，比如泛型、元组。 但是：现阶段Swift能完全取代Objective-C吗？答案是还不行。其实到现在为止Swift离完全替代Objective-C还是很遥远，因为Apple内部一直在用Objective-C来做一些Framework的开发，底层也不可能用Swift实现，所以现在更多的替代是体现在外部开发。 Swift对比Objective-C的优缺点优点： swift是类型安全的语言，注重安全，OC注重灵活 swift注重面向协议编程、函数式编程、面向对象编程，OC注重面向对象编程 swift注重值类型，OC注重指针和引用 swift是静态类型语言，OC是动态类型语言 swift容易阅读，文件结构和大部分语法简易化，只有.swift文件，结尾不需要分号 swift中的可选类型，是用于所有数据类型，而不仅仅局限于类。相比于OC中的nil更加安全和简明 swift中的泛型类型更加方便和通用，而非OC中只能为集合类型添加泛型 swift中各种方便快捷的**[高阶函数]**（函数式编程）（Swift的标准数组支持三个高阶函数：map，filter和reduce,以及map的扩展flatMap） swift新增了两种权限，细化权限。open &gt; public &gt; internal(默认)&gt; fileprivate &gt; private swift中独有的**元组类型(tuples)**，把多个值组合成复合值。元组内的值可以是任何类型，并不要求是相同类型的。 swift支持函数式编程，Objc本身是不支持的，需要通过引入ReactiveCocoa这个库才可支持函数式编程。 缺点 版本不稳定 公司使用比例不高，使用人数比例偏低 社区的开源项目偏少，毕竟OC独大好多年，很多优秀的类库都不支持Swift，不过这种状况正在改变，现在有好多优秀的Swift的开源类库了 偶尔开发中遇到的一些问题，很难查找到相关资料，这是一个弊端。 对于不支持Swift的一些第三方类库，如果非得使用，只能混合编程，利用桥接文件实现。 App体积变大：使用 Swift 后， App 体积大概增加 5-8 M 左右，对体积大小敏感的慎用。（体积变大的原因是因为 Swift 还在变化，所以 Apple 没有在 iOS 系统里放入 Swift 的运行库，反而是每个 App 里都要包含其对应的 Swift 运行库。） 上线方式改变：在上线的时候，不能使用application Loader上传包文件，会提示你丢失了swift support files，应该使用xcode直接上传。 整体总结 String：Swift中String操作已经甩OC三百万条街 Discriminated Union：swift里的enum. 是静态语言独有的特性. 安全： 由于swift的strong static type system，编译器可帮你检查出更多问题，而不是在运行时突然boom，还有一个很牛逼的安全特性就是OptionalType。 快速： 静态语言相对来说语言本身速度更快，swift编译期间就能生成vtable，确定具体要调用的方法，比起oc的动态派发自然是更快，当然处理到与oc之间的桥接部分，可能不一定比OC快。 细节使用区别 在 Swift 中没有了 main.m，@UIApplicationMain 是程序入口 swift不分.h和.m文件 ，一个类只有.swift一个文件，所以整体的文件数量比起OC有一定减少。 swift句尾不需要分号 ，除非你想在一行中写三行代码就加分号隔开。 在 Swift 中，一个类就是用一对 { } 括起的，没有 @implementation 和 @end swift数据类型都会自动判断 ， 只区分变量var 和常量let 强制类型转换格式不同 OC强转：(int)a Swift强转：Int(a) 关于BOOL类型更加严格 ，Swift不再是OC的非0就是真，而是true才是真false才是假 swift的 循环语句中必须加{}就算只有一行代码也必须要加 swift的switch语句后面可以跟各种数据类型了 ，如Int、字符串都行，并且里面不用写break（OC好像不能字符串） swift if后的括号可以省略: if a&gt;b {}，而OC里 if后面必须写括号。 swift打印 用print(“”) 打印变量时可以 print(“(value)”)，不用像OC那样记很多%@，d%等。 Swift3的Any可以代表任何类型的值，无论是类、枚举、结构体还是任何其他Swift类型，这个对应OC中的id类型。 在OC中alloc / init对应() 在 OC 中 alloc &#x2F; initWithXXX 对应 (XXX: ) 在 OC 中的类函数调用，在 Swift 中，直接使用. 在 Swift 中，绝大多数可以省略 self.，建议一般不写，可以提高对语境的理解（闭包时会体会到） 在 OC 中的 枚举类型使用 UIButtonTypeContactAdd，而 Swift 中分开了，操作热键：回车-&gt; 向右 -&gt;. Swift 中，枚举类型的前缀可以省略，如：.ContactAdd，但是：很多时候没有智能提示 swift中的 更灵活 a...b 表示 [a,b] 包括a和b 。 （如3…5 就是范围取3，4，5） a..&lt;b 表示 [a,b) 包括a，不包括b 。 （如3…5 就是范围取3，4） 常见的如for循环：for i in 0...9&#123;&#125; 循环引用问题Objective-C中循环引用也是遇到比较多的，一不小心就会导致循环引用，甚至导致内存问题 Swift - 既可用于变量也可用于常量，self不是可选项，如果self已经被释放，则出现野指针访问 Objective-C - 如果self已经被释放，则出现野指针访问 "},{"title":"简述OC语言","date":"2018-02-25T04:15:51.000Z","url":"/25/%E7%AE%80%E8%BF%B0OC%E8%AF%AD%E8%A8%80/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"对于一门语言的学习是需要时间领悟的，而对于一些原理性的问题，我们需要清楚其核心思想，知其然而知其所以然，这样才能有利于自己的后续发展。本文只是简述，没有面面具到。 OC是在C语言的基础上加入了一些面向对象的特性（封装，继承，多态），OC完全兼容C语言，在代码中，可以混用C，甚至是C++代码（C++是在C语言的基础上开发的一种面向对象编程语言）。 抽象是面向对象的思想基础，抽象包括两个方面，一是过程抽象，二是数据抽象，抽象是一种思想，封装继承和多态是这种思想的实现。 封装 封装是把过程和数据包围起来，有限制的对数据的访问。 继承 继承是一种层次模型，允许和鼓励类的重用，继承性很好的解决了软件的可重用性问题。但是，不恰当地使用继承导致的最大的一个缺陷特征就是高耦合（有时候也是一种需求），恰当使用继承可以达到层级关系明显，功能划分清晰。 多态 其本质是子类通过覆盖或重载父类的方法，来使得对同一类对象同一方法的调用产生不同的结果。 消息传递 消息传递模型（Message Passing）是Objective-C语言的核心机制。在Objective-C中，没有方法调用这种说法，只有消息传递。在C++或Java中调用某个类的方法，在Objective-C中是给该类发送一个消息。在C++或Java里，类与类的行为方法之间的关系非常紧密，一个方法必定属于一个类，且于编译时就已经绑定在一起，所以你不可能调用一个类里没有的方法。而在Objective-C中就比较简单了，类和消息之间是松耦合的，方法调用只是向某个类发送一个消息，该类可以在运行时再确定怎么处理接受到的消息。也就是说，一个类不保证一定会响应接收到的消息，如果收到了一个无法处理的消息，那么程序就是简单报一个错。甚至你可以向一个值为nil的空对象发送消息，系统都不会出错或宕掉。这种设计本身也比较符合软件的隐喻。 动态性（Runtime） Objective-C 是面相运行时的语言，它会尽可能的把编译和链接时要执行的逻辑延迟到运行时。使用Runtime可以按需要把消息重定向给合适的对象，交换方法的实现等等。 Runtime简称运行时，其中最主要的是消息机制，是一个主要使用 C 和汇编写的库，为 C 添加了面相对象的能力并创造了 Objective-C。OC的函数调用称为消息发送。属于动态调用过程。在编译的时候并不能决定真正调用哪个函数（在编 译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。而C语言在编译阶段就会报错）。只有在真正运行的时候才会根据函数的名称找 到对应的函数来调用。 如： 编译器执行上述转换。在objc_msgSend函数中，首先通过obj的isa指针找到obj对应的class。每个对象内部都默认有一个isa指针指向这个对象所使用的类。isa是对象中的隐藏指针，指向创建这个对象的类。在Class中先去cache中通过SEL查找对应函数method（cache中method列表是以SEL为key通过hash表来存储的，这样能提高函数查找速度），若cache中未找到,再去methodList中查找，若methodlist中未找到，则取superClass中查找。若能找到，则将method加入到cache中，以方便下次查找，并通过method中的函数指针跳转到对应的函数中去执行。 OC的动态性的三方面 动态类型、动态绑定、动态加载（动态是因为 到运行时(runtime)才会做一些事情） 动态类型：就是id类型； 动态绑定：需要用到@selector/SEL，SEL并不是C里面的函数指针，SEL变量只是一个整数，他是该方法的ID。我们是根据一个ID整数来查找方法，不仅方便，而且效率更高。 动态加载：就是根据需求动态地加载资源，在运行时加载新类。 在运行时创建一个新类，只需要3步: 1、为 class pair分配存储空间 ,使用 objc_allocateClassPair函数 2、增加需要的方法使用class_addMethod函数,增加实例变量用class_addIvar 3 、用objc_registerClassPair函数注册这个类,以便它能被别人使用。 强大的Method Swizzling（方法交叉使用） 在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP类似函数指针，指向具体的Method实现。 用 method_exchangeImplementations 来交换2个方法中的IMP， 用 class_replaceMethod 来修改类， 用 method_setImplementation 来直接设置某个方法的IMP，归根结底，都是偷换了selector的IMP。 RunLoop RunLoop是一让线程能随时处理事件但不退出的机制。 RunLoop的四个作用为： 1、使程序一直运行接受用户输入； 2、决定程序在何时应该处理哪些Event； 3、调用解耦； 4、节省CPU时间。 主线程的runloop默认是启动的。 Cocoa中的NSRunLoop类并不是线程安全的。 对其它线程来说，runloop默认是没有启动的。 Runloop在你要和线程有更多的交互时才需要，比如以下情况： 1.使用端口或自定义输入源来和其他线程通信; 2.使用线程的定时器; 3.Cocoa中使用任何performSelector…的方法; 4.使线程周期性工作; 事件响应链 对于IOS设备用户来说，操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。 对应的事件类型有以下三种： 1、触屏事件（Touch Event） 2、运动事件（Motion Event） 3、远端控制事件（Remote-Control Event） 传递链：由系统向离用户最近的view传递。 响应链：由离用户最近的view向系统传递。 UIResponder是所有响应对象的基类，在UIResponder类中定义了处理上述各种事件的接口。我们熟悉的UIApplication、 UIViewController、UIWindow和所有继承自UIView的UIKit类都直接或间接的继承自UIResponder，所以它们的实例都是可以构成响应者链的响应者对象。 响应者链有以下特点： 1、响应者链通常是由视图（UIView）构成的； 2、一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）； 3、视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图； 4、单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者，Cocoa Touch应用不像Cocoa应用，它只有一个UIWindow对象，因此整个响应者链要简单一点； 5、单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环。 生命周期 1、application didFinishLaunchingWithOptions：当应用程序启动时执行，应用程序启动入口，只在应用程序启动时执行一次。若用户直接启动，lauchOptions内无数据,若通过其他方式启动应用，lauchOptions包含对应方式的内容。 2、applicationWillResignActive：在应用程序将要由活动状态切换到非活动状态时候，要执行的委托调用，如 按下 home 按钮，返回主屏幕，或全屏之间切换应用程序等。 3、applicationDidEnterBackground：在应用程序已进入后台程序时，要执行的委托调用。 4、applicationWillEnterForeground：在应用程序将要进入前台时(被激活)，要执行的委托调用，刚好与applicationWillResignActive 方法相对应。 5、applicationDidBecomeActive：在应用程序已被激活后，要执行的委托调用，刚好与applicationDidEnterBackground 方法相对应。 6、applicationWillTerminate：在应用程序要完全推出的时候，要执行的委托调用，这个需要要设置UIApplicationExitsOnSuspend的键值。 初次启动： iOS_didFinishLaunchingWithOptions iOS_applicationDidBecomeActive 按下home键： iOS_applicationWillResignActive iOS_applicationDidEnterBackground 点击程序图标进入： iOS_applicationWillEnterForeground iOS_applicationDidBecomeActive 当应用程序进入后台时,应该保存用户数据或状态信息，所有没写到磁盘的文件或信息，在进入后台时，最后都写到磁盘去，因为程序可能在后台被杀死。释放尽可能释放的内存。 - (void)applicationDidEnterBackground:(UIApplication *)application 方法有大概5秒的时间让你完成这些任务。如果超过时间还有未完成的任务，你的程序就会被终止而且从内存中清除。 如果还需要长时间的运行任务，可以在该方法中调用 "},{"title":"iOS多线程编程之三：GCD基础知识","date":"2018-01-15T13:25:11.000Z","url":"/15/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%B8%89-GCD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","tags":[["多线程","/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、引言在软件开发中使用多线程可以大大的提升用户体验度，增加工作效率。iOS系统中提供了多种分线程编程的方法，在前两篇博客都有提及： NSThread类进行多线程编程：iOS多线程编程之一:NSThread线程管理 NSOperation进行多线程操作编程：iOS多线程编程之二:NSOperation与NSOperationQueue 上两个进行多线程编程的机制都是封装于Object-C的类与方法。这篇博客将讨论的Grand Central Dispatch(GCD)机制，则是基于C语言的，相比上面两种机制，GCD更加高效，并且线程有系统管理，会自动运用多核运算。因为这些优势，GCD是apple推荐我们使用的多线程解决方案。 二、GCD的调度机制GCD机制中一个很重要的概念是调度队列，我们对线程的操作实际上是由调度队列完成的。我们只需要将要执行的任务添加到合适的调度队列中即可。 1、调度队列的类型调度队列有三种类型： （1）主队列 其中的任务在主线程中执行，因为其会阻塞主线程，所以这是一个串行的队列。可以通过dispatch_get_main_queue()方法得到。 （2）全局并行队列 队列中任务的执行方式是严格按照先进先出的模式进行了。如果是串行的队列，则当一个任务结束后，才会开启另一个任务，如果是并行队列，则任务的开启顺序是和添加顺序一致的。系统为iOS应用自动创建了四个全局共享的并发队列。使用如下函数获得： dispatch_get_global_queue(long identifier, unsigned long flags); 其中第一个参数是这个队列的id，系统的四个全局队列默认的优先级不同，这个参数可填的定义如下： 这个函数的第二个参数，按照官方文档的说法是有待未来使用，现在我们都填0即可。 （3）自定义队列 上面的两种队列都是系统为我们创建好的，我们只需要获取到他们，将任务添加即可。当然，我们可可以创建我们自己的队列，包括串行的和并行的。使用如下方法创建： 其中，第一个参数是这个队列的名字，第二个参数决定创建的是串行的还是并行的队列。填写DISPATCH_QUEUE_SERIAL或者NULL创建串行队列，填写DISPATCH_QUEUE_CONCURRENT创建并行队列。 2、添加任务到队列中使用dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)函数或者dispatch_async(dispatch_queue_t queue, dispatch_block_t block)函数来同步或者异步的执行任务，示例如下： 打印结果如下： 可以看出第一个任务在主线程中执行，第二个在分线程中执行。 三、队列调度机制的更多技巧通过上面的演示，我们已经可以运用队列进行多线程的执行任务，但是GCD的强大之处远远不止如此。 1、使用队列组如果有这样三个任务，A与B是没有关系的，他们可以并行执行，C必须在A,B结束之后才能执行，当然，实现这样的逻辑并不困难，使用KVO就可以实现，但是使用队列组处理这样的逻辑，代码会更加清晰简单。 可以使用dispatch_group_create()创建一个队列组，使用如下函数将队列添加到队列组中： 队列组中的队列是异步执行的，示例如下： 打印出来的信息如下： 可以看出，队列中的任务是异步执行的，并且等待队列组中队列任务全部执行后才执行后面的任务。这样的做法在实际应用中我们很少使用，通常我们会把后续的任务在放在异步中执行，做法如下： 打印信息如下： 可以看出GCD的强大了吧，复杂的任务逻辑关系因为GCD变得十分清晰简单。 2、循环机制一开始我们就提到，GCD相比NSOperation的优势在于多核心的应用，更深得挖掘出了硬件的性能。GCD在多核方面的一个明显的特点就是循环机制。 打印结果如下： 可以看出，程序的运行效率又会高许多。 3、消息传递机制dispatch_source_t类型的对象可以用来传递和接受某个消息，然后执行block方法，示例如下： 4、发送和等待信号GCD中还有一个重要的概念是信号量。它的用法法消息的传递有所类似，通过代码来解释： 通过发送信号，可以试信号量+1，每次执行过等待信号后，信号量会-1；如此，我们可以很方便的控制不同队列中方法的执行流程。 5、挂起和开启任务队列GCD还提供了暂停与开始任务的方法，使用 void dispatch_suspend(dispatch_object_t object); 可以将队列或者队列组进行暂时的挂起，使用 void dispatch_resume(dispatch_object_t object); 将队列或者队列组重新开启。 需要注意的是，暂停队列时，队列中正在执行的任务并不会被中断，会挂起未开启的任务。 四、关于内存管理GCD虽然是基于C语言封装的框架，使用了面向对象的思想。因此，它的内存管理是需要我们注意的，不论是ARC或者MRC，我们都应该手动去处理这些对象。还好，GCD的内存管理思路和Object—C是兼容的，我们使用dispatch_retain()和dispatch_release()来将引用对象的计数进行加减。这一点十分重要，切记切记。"},{"title":"iOS多线程编程之二：NSOperation与NSOperationQueue","date":"2018-01-07T11:56:34.000Z","url":"/07/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%BA%8C-NSOperation%E4%B8%8ENSOperationQueue/","tags":[["多线程","/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、NSOperation解析NSOperation是基于Object-C封装的一套管理与执行线程操作的类。这个类是一个抽象类，通常情况下，我们会使用NSInvocationOperation和NSBlockOperation这两个子类进行多线程的开发，当然我们也可以写继承于NSOperation的类，封装我们自己的操作类。 1、NSOperation抽象类中提供的逻辑方法操作开始执行 在子类中可以重写这个方法，实现执行的方法 取消执行 获取当操作状态的几个属性 阻塞当前线程直到操作完成 设置在操作队列中的优先级 其中NSOperationQueuePriority的枚举如下： 设置操作完成后的回调block 设置操作的优先级 设置操作的名称 2、带block的操作类实例——NSBlockOperationNSBlockOperation是NSOperation的一个子类，其可以异步的执行多个block，当所有的block都完成时，这个操作才算完成。 初始化方法： 在操作中添加block 添加进去的block的数组 示例如下： 打印情况如下，可以看出，两个block块的执行是异步的： 3、使用NSInvocationOperation调用方法根据选择器创建一个对象 通过Invocation创建一个对象 这个类执行的操作是与调用它的线程同步的，示例如下： 通过打印结果可以看出其执行的同步性。 二、操作之间的依赖关系依赖关系和优先级的作用很像，却也不同。如果一个操作A依赖于另一个操作B，那么只有当B操作完成后，A操作才会执行。操作添加依赖的 添加一个依赖： 删除一个依赖 原则上说，一个操作对象的依赖可以添加多个，并且当所有依赖都执行完成后才会执行这个操作。 三、NSOperationQueue操作队列NSOperationQueue是操作队列类，通过上面的介绍，我们已经可以理解操作，并且操作默认的执行方式是串行的，尽管NSBlockOperation中的block块间是并行执行的，但其和外部操作依然是串行的。如果将操作放入操作队列中，则默认为并行执行的。 示例如下： 打印信息如下： 可以看出来，队列的操作是在一个新的线程中执行的，并且操作队列之中的操作也都是异步执行的。 在操作队列中添加一个操作任务： 在队列中插入一组操作任务，后面的参数设置是否队列中得任务都执行完成后再执行这一组操作： 在队列中添加一个block操作 获取操作队列中的所有操作的数组 获取操作队列中操作的个数 设置队列最大并行操作数量 设置是否暂停队列任务执行 设置队列名字 设置队列的优先级别（iOS8后支持） 取消队列中所有操作任务 阻塞当前线程，直到队列中所有任务完成 获取当前执行的队列 获取主线程中的操作队列 四、队列中操作的执行顺序法则1、决定于依赖关系，只有当这个操作的依赖全部执行完成后，它才会被执行。 2、影响于优先级，优先级高的会先执行。"},{"title":"iOS多线程编程之一：NSThread线程管理","date":"2018-01-02T07:21:22.000Z","url":"/02/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B9%8B%E4%B8%80-NSThread%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/","tags":[["多线程","/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"NSTread是iOS中进行多线程开发的一个类，其结构逻辑清晰，使用十分方便，但其封装度和性能不高，线程周期，加锁等需要手动处理。 一、NSThread类方法总结获取当前线程 这个方法通过开启一个新的线程执行选择器方法 线程用法示例如下： 新启的线程和主线程是异步的 程序是否是多线程执行 线程字典，我们可以为特殊的线程设置键值对 线程在某个时间执行 线程在等待一个时间间隔后执行 结束线程 设置线程的优先级，取值的范围为0-1，1的优先级最高 这个属性是iOS8之后的新特性，将优先级更人性化的封装了起来 判断是否是主线程 获取主线程 二、属性与成员方法总结初始化方法，选择器可以带一个参数 线程是否正在执行 线程是否已经执行结束 线程是否已经取消执行 三、隐式的通过NSThread进行多线程编程NSObject的一个类别中提供了支持多线程的方法，如下： 这个函数指定在主线程执行一个选择器，arg是参数，wait是是否立即执行，如果YES，则会阻塞当前主线程的任务，NO则会等待当前任务结束后执行。 这个函数指定在某个线程执行选择器 指定在后台线程中执行选择器 "},{"title":"iOS 通过crash日志定位bug代码位置","date":"2017-10-24T08:07:34.000Z","url":"/24/iOS-%E6%A0%B9%E6%8D%AE-crash-%E5%B4%A9%E6%BA%83-%E6%8A%A5%E5%91%8A%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%AE%9A%E4%BD%8D%E5%88%B0%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE/","categories":[["开发工具","/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"]],"content":"项目上线之后经常会遇到一些崩溃的问题，此时因为无法重现很难定位到相应代码位置，可以通过一些第三方工具来完成crash日志的统计，如友盟和bugly，然后完成代码的定位，本文主要论述如何使用dSYM文件和堆栈信息定位crash代码的位置 以下将通过两种方法来完成定位： ps：由于某种未知因素，友盟的日志通过方法一能定位成功，bugly的日志通过方法二才定位成功，推荐方法二 一、通过dwarfdump方法定位1.获取dSYM包 在 XCode中， Window-&gt;Organizer-&gt;选择提交到App Store的Archies-&gt;右键，showin finder -&gt;右键－&gt;显示包内容，在dSYMs文件夹里的xxx.app.dSYM就是符号表文件。这里包含着debug信息 2.定位之前，首先要确定bug的版本和dSYM包是否匹配 找到错误部分 定位 在打印的信息中可以找到错误代码所在类的名称和行数 二、通过基地址查找定位 获取dSYM包 在 XCode中， Window-&gt;Organizer-&gt;选择提交到App Store的Archies-&gt;右键，showin finder -&gt;右键－&gt;显示包内容，在dSYMs文件夹里的xxx.app.dSYM就是符号表文件。这里包含着debug信息 定位之前，首先要确定bug的版本和dSYM包是否匹配 找到错误部分 定位 即可定位到代码位置 这样就可以找到错误代码所在位置了"},{"title":"iOS - UIWindow","date":"2017-10-13T06:35:45.000Z","url":"/13/iOS-UIWindow/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"一、简单介绍UIWindow是一种特殊的UIView，通常在一个app中只会有一个UIWindow iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的view，最后将控制器的view添加到UIWindow上，于是控制器的view就显示在屏幕上了 一个iOS程序之所以能显示到屏幕上，完全是因为它有UIWindow。也就说，没有UIWindow，就看不见任何UI界面 补充：UIWindow是创建的第一个视图控件（创建的第一个对象是UIapplication）如下图： 添加 先创建UIwindow,再创建控制器，创建控制器的view，然后将控制器的view添加到UIWindow上。 文档中关于该部分的解释： 二、UIWindow的创建过程1.简单说明 创建一个空的项目，就可以看到UIWindow是怎么出来的了。在程序启动完毕之后就会调用一次，创建过程如下： 提示：应用程序启动之后，先创建Application，再创建它的代理，之后创建UIwindow。UIWindow继承自UIview。 2.把view添加到uiwindow 创建一个控制器，把view添加到uiwindow上面（有两种方式） （1）直接将控制器的view添加到UIWindow中，并不理会它对应的控制器 [self.window addsubview:vc.view]; （2）设置uiwindow的根控制器，自动将rootviewcontroller的view添加到window中，负责管理rootviewcontroller的生命周期 [self.window.rootviewcontroller=vc]; 两个方法的区别： 以后的开发中，建议使用（2）.因为方法（1）存在一些问题，比如说控制器上面可能由按钮，需要监听按钮的点击事件，如果是1，那么按钮的事件应该由控制器来进行管理。但控制器是一个局部变量，控制器此时已经不存在了，但是控制器的view还在，此时有可能会报错。注意：方法执行完，这个控制器就已经不存在了。 问题描述1：当view发生一些事件的时候，通知控制器，但是控制器已经销毁了，所以可能出现未知的错误。 问题描述2：添加一个开关按钮，让屏幕360度旋转（两者的效果不一样）。当发生屏幕旋转事件的时候，UIapplication对象会将旋转事件传递给uiwindow,uiwindow又会将旋转事件传递给它的根控制器，由根控制器决定是否需要旋转 UIapplication-&gt;uiwindow-&gt;根控制器（第一种方式没有根控制器，所以不能跟着旋转）。 提示：不通过控制器的view也可以做开发，但是在实际开发中，不要这么做，不要直接把view添加到UIWindow上面去。因为，难以管理。 3.在有storyboard的项目中，UIWindow是如何创建的？ 为什么创建一个storyboard，没有看到创建uiwindow的过程？ 它其实是把创建UIWindow的过程给屏蔽起来了。可以把代理的UIWindow的属性的值打印出来NSLog(@“window&#x3D;%p”,self.window);打印出来确实是有值的，说明确实创建了UIWindow.不仅创建了UIWindow，默认还创建了UIWindow对应的控制器，也可以打印进行查看。NSLog(@“%@“,self.window.rootviewcontroller); 有storyboard的项目中的创建过程： 当用户点击应用程序图标的时候，先执行Main函数，执行UIApplicationMain（）,根据其第三个和第四个参数创建Application，创建代理，并且把代理设置给application（看项目配置文件info.plist里面的storyboard的name，根据这个name找到对应的storyboard），开启一个事件循环，当程序加载完毕，他会调用代理的didFinishLaunchingWithOptions:方法。在调用didFinishLaunchingWithOptions:方法之前，会加载storyboard，在加载的时候创建一个window，接下来会创建箭头所指向的控制器，把该控制器设置为UIWindow的根控制器，接下来再将window显示出来，即看到了运行后显示的界面。（提示：关于这部分可以查看story的初始化的文档） 三、如何获取window?1.主窗口和次窗口 [self.window makekeyandvisible]让窗口成为主窗口，并且显示出来。有这个方法，才能把信息显示到屏幕上。 因为Window有makekeyandvisible这个方法，可以让这个Window凭空的显示出来，而其他的view没有这个方法，所以它只能依赖于Window，Window显示出来后，view才依附在Window上显示出来。 [self.window make keywindow] //让uiwindow成为主窗口，但不显示。 2.获取UIwindow （1）[UIApplication sharedApplication].windows 在本应用中打开的UIWindow列表，这样就可以接触应用中的任何一个UIView对象(平时输入文字弹出的键盘，就处在一个新的UIWindow中) （2）[UIApplication sharedApplication].keyWindow（获取应用程序的主窗口）用来接收键盘以及非触摸类的消息事件的UIWindow，而且程序中每个时刻只能有一个UIWindow是keyWindow。 提示：如果某个UIWindow内部的文本框不能输入文字，可能是因为这个UIWindow不是keyWindow （3）view.window获得某个UIView所在的UIWindow 四、四大对象的关系图 五、主窗口和次窗口说明代码： 代码说明： 再创建一个窗口（主窗口和次窗口的区别） 局部变量，需要定义一个Window属性来保存变量。 window的属性定义为strong，就是为了让其不销毁。 一个应用程序只能有一个主窗口，程序中创建了两个Window，那么谁是主窗口？后面的窗口能覆盖前面的窗口。 提示：如果UItextfield不显示，可以考虑设置它的样式，因为其创建默认是虚线的，没有边框。 在ios7里边，主窗口和次窗口是没有区别的 在ios7以前中有区别：哪个是主窗口，后面设置为主窗口会把之前设置的覆盖掉。（只有主窗口才能响应键盘的输入事件，如果不能输入内容，可以查看是否是显示在主窗口上，不在主窗口上的不能响应。） 六、补充说明在有storyboard中的创建过程： 先执行Main函数，执行UIApplicationMain()，根据其第三个和第四个参数创建Application，创建代理，并且把代理设置给application，根据项目配置文件info.plist里面的storyboard的name，找到对应的storyboard，接下来创建一个window，之后创建它的初始化控制器（就是箭头所指向的控制器），自动把该控制器设置为UIWindow的根控制器，接下来再将window显示出来，即看到了运行后显示的界面。 注意这个控制器属性面板上的“初始化控制器属性”。 在没有storyboard中的创建过程： 先执行Main函数，执行UIApplicationMain（）,根据其第三个和第四个参数创建Application，创建代理，并且把代理设置给application，开启一个事件循环，当程序加载完毕，他会调用代理的didFinishLaunchingWithOptions:方法。在该方法中，会创建一个Window,然后创建一个控制器，并把该控制器设置为UIWindow的根控制器，接下来再将window显示出来，即看到了运行后显示的界面。"},{"title":"经典排序算法","date":"2017-09-20T12:55:25.000Z","url":"/20/%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"许多高级语言中都提供有排序函数，但是掌握一些经典排序算法的基本原理和编码方法还是很有必要，这个学习过程可以帮助我们更好的理解每种排序算法的设计思路。 一、直接插入排序直接插入排序是最简单的一种排序算法，也最容易理解。它的核心思想为将元素逐个插入一个有序的数列中。用文字描述可以分为如下几步： 1.把数列中的第一个元素取出，作为有序数列的起始元素。 2.依次拿数列中的其他元素与有序数列中的元素进行比较，将其插入正确的位置。 用图示描述插入排序如下： 直接插入排序的特点是对新元素的每轮插入前，有序数列中的所有元素都是排序好的，即任意时刻，被排序动过的元素组成的数列都是有序的。 用C实现的简单插入排序： 二、二分插入排序(折半插入排序)二分插入排序也是插入排序的一种，其又叫做折半插入排序。它与直接插入排序的唯一不同只在于查找插入位置的方式。直接插入排序是通过遍历来查找要插入元素的位置，二分插入排序则是通过二分法来查找要插入的位置，之后将此位置所有元素后移，将排序的元素进行插入。 C实现的二分插入排序： 三、希尔排序​ 希尔排序也是插入排序的一种，它先将整个数列分割成若干个小的子序列进行插入排序，逐渐减少子序列的个数，直到最后组合成一个数列，完成整个排序过程。希尔排序的过程使用文字描述可以表示为如下几步： 1.假设数列元素个数为n，先取一个小于n的增量d1，将所有间隔d1距离的元素放为1组进行插入排序，d1通常取值n&#x2F;2，向下取整。 2.再次取d2&lt;d1，将所有间隔d2距离的元素放为1组进行插入排序，通常d2取值为d1&#x2F;2，向下取整。 3.重复步骤2，直到取得d等于1。 图示希尔排序如下： C实现的希尔排序： 四、选择排序​ 前边所说的3种排序算法原理上都是插入排序，即从无序数列中逐个取元素将其插入到有序数列中的合适位置。选择排序则刚好与之相反，其从无序数列中先找到最小值，放在排序数列首部，在依次找到剩余数列的中最小值追加入有序数列，最终完成数列的排序。用文字描述选择排序步骤不如： 1.找到数列中的最小值，将其作为有序数列的第一个元素。 2.从剩余数列中找到最小值，追加入有序数列。 3.重复步骤2，直到排完整个数列。 图示描述选择排序如下： C实现的选择排序算法： 五、冒泡排序 冒泡排序和选择排序是我们学习编程课时必不可少的两种排序算法，冒泡排序算法的核心是每次比较相邻的连个元素，如果它们的顺序不对，则进行交换，一轮排序下来，最大值一定被排序到数列的末端。之后除去最后一个元素再进行第二轮冒泡，直到整个数列排序完成。用文字描述冒泡排序的过程如下： 1.从左向右依次比较相邻两元素，如果顺序不对，则进行交换，最终最大的元素被放在最后。 2.除去最后一个元素，重复步骤1，最终剩下元素中最大的被放在倒数第2个位置。 3.继续上面的重复，直到排完整个数列。 C实现的冒泡排序算法： 六、双向冒泡排序 双向冒泡排序是冒泡排序的一种变体，冒泡排序每次比较都是从左向右，找出最大的放在最后。双向冒泡排序则是第一轮从左向右将最大的放最后，第二轮从右向左将最小的放最首，如此交替直到整个数列排序完成。文字描述双向冒泡排序步骤如下： 1.从左向右依次比较相邻两个元素，如果顺序不对，则进行交换，如此一轮下来，最大的元素在最后。 2.除去已经排序好的元素，从右向左依次比较相邻的两个元素，如果顺序不对，则进行交换，最小的元素在首部。 3.交替重复步骤1与步骤2直到排序完成。 双向冒泡排序示意图如下： C实现的双向冒泡排序算法： 七、快速排序算法 快速排序算法和基本思路是通过一趟排序将数列分成两部分，其中一部分的所有数据都比另一部分小。之后在分别在两个子数列中进行递归，直到最终排序完成。快速排序算法的核心是递归，因此其效率十分高。用文字描述快速排序的步骤如下： 1.随机取一个元素作为基准，将小于此元素的数据都放在此元素的左侧，大于此元素的数据都放在此元素的右侧，将数列分隔成左右两个子数列。 2.分别对左右子数列进行步骤1的递归，直到数列长度为1或者0，表示排序完成。 C语言实现的快速排序： 八、堆排序 堆排序是比快速排序更加复杂的一种排序算法。堆排序使用到了堆这样一种数据结构。首先我们需要搞清楚什么是堆结构。堆是一种类似完全二叉树，同时又满足如下条件的数据结构：所有子节点的值总是小于(大于)父节点。所有子节点的值都小于父节点的堆叫大顶堆，所有子节点都大于父节点的堆叫小顶堆。 二叉树你应该比较熟悉，下图就是一个小顶堆的示例： 此二叉树中任何一个子节点的值都是大于父节点。如何将数列构造成这样一个堆结构呢，其实十分简单，将数列按照从上到下，从左到右的原则来构造完全二叉树即可。例如如下数列[1, 54, 2, 64, 12, 65, 76, 46, 34, 98, 34]如果将其构造成堆如下图所示： 正常情况下，这个由数组映射成的二叉树并不符合我们堆的要求，否则也就不需要我们用算法来排序了。要让这个二叉树符合要求，我们需要进行整理，即从末节点开始进行调整，例如先从12，98，34中找到最小的，放在现在12所在的位置，然后从64，46，34中找到最小的元素进行上浮，接着再一层层上浮上去，直到堆顶元素为所有元素中的最小元素。整理完成后，我们只需要将堆顶元素和最后一个元素进行交换，之后除掉最后一个元素再进行堆整理，整理完成后再将顶元素(此时为第2小)与倒数第二个元素交换，依次进行下去，即可完成数列的排序。 用文字描述堆排序步骤如下： 1.先将数列整理成符合要求的堆。 2.将首末元素交换。 3.除掉最后一个元素在进行堆的整理。 4.重复进行2和3，直到数列排序完成。 C语言实现的堆排序算法： 九、归并排序​ 归并排序的核心并不是交换元素的顺序，而是将数列分成多个有序小数列，将相邻的小数列进行归并。文字描述归并排序步骤如下： 1.把长度为n的数列分成长度为1的n个数列。 2.相邻数列进行排序归并。 3.重复操作2，直到所有数列归并成1个整体。 C语言实现的归并排序算法： "},{"title":"iOS UIBezierPath贝塞尔曲线常用方法","date":"2017-08-25T13:46:11.000Z","url":"/25/iOS-UIBezierPath%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"关于 UIBezierPathUIBezierPath这个类在UIKit中， 是Core Graphics框架关于path的一个封装，使用此类可以定义简单的形状，比如我们常用到，矩形，圆形，椭圆，弧，或者不规则的多边形 UIBezierPath 基本使用方法UIBezierPath对象是CGPathRef数据类型的封装。path如果是基于矢量形状的，都用直线或曲线去创建。我们一般使用UIBezierPath都是在重写view的drawRect方法这种情形。我们用直线去创建矩形或多边形，使用曲线创建弧或者圆。创建和使用path对象步骤：1、 重写View的drawRect方法2、 创建UIBezierPath的对象3、 使用方法moveToPoint: 设置初始点4、 根据具体要求使用UIBezierPath类方法绘图（比如要画线、矩形、圆、弧？等）5、 设置UIBezierPath对象相关属性 （比如lineWidth、lineJoinStyle、aPath.lineCapStyle、color）6、 使用stroke 或者 fill方法结束绘图 比如我们想要画一条线： 其他基本使用方法在介绍其他使用方法之前，我们先来看一下 path的几个属性，以便下面我进行设置。1、[color set];设置线条颜色，也就是相当于画笔颜色2、path.lineWidth = 5.0;这个很好理解了，就是划线的宽度3、path.lineCapStyle这个线段起点是终点的样式，这个样式有三种： 3.1 、kCGLineCapButt该属性值指定不绘制端点， 线条结尾处直接结束。这是默认值。 3.2、kCGLineCapRound 该属性值指定绘制圆形端点， 线条结尾处绘制一个直径为线条宽度的半圆。 3.3、kCGLineCapSquare 该属性值指定绘制方形端点。 线条结尾处绘制半个边长为线条宽度的正方形。需要说 明的是，这种形状的端点与“butt”形状的端点十分相似，只是采用这种形式的端点的线条略长一点而已4、path.lineJoinStyle这个属性是用来设置两条线连结点的样式，同样它也有三种样式供我们选择 4.1、kCGLineJoinMiter 斜接 4.2、kCGLineJoinRound 圆滑衔接 4.3、kCGLineJoinBevel 斜角连接5、[path stroke];用 stroke 得到的是不被填充的 view ，[path fill]; 用 fill 得到的内部被填充的 view，这点在下面的代码还有绘制得到的图片中有，可以体会一下这两者的不同。 绘制多边形 绘制多边形，实际上就是又一些直线条连成，主要使用moveToPoint: 和addLineToPoint:方法去创建，moveToPoint:这个方法是设置起始点，意味着从这个点开始，我们就可以使用addLineToPoint:去设置我们想要创建的多边形经过的点，也就是两线相交的那个点，用addLineToPoint:去创建一个形状的线段，我们可以连续创建line，每一个line的起点都是先前的终点，终点就是指定的点，将线段连接起来就是我们想要创建的多边形了。 在这里我们可以看到最后第五条线是用[path closePath];得到的，closePath方法不仅结束一个shape的subpath表述，它也在最后一个点和第一个点之间画一条线段，这个一个便利的方法我们不需要去画最后一条线了， 哈哈哈哈。这里我们用到的是[path fill];//颜色填充进行坐标连点，但是我们看见的是五边形内部被颜色填充了， 如果我们使用[path stroke];那我们得到的就是一个用线画的五边形。 画矩形或者正方形大家都知道正方形就是特殊的矩形咯，不多讲。只说矩形。使用+ (UIBezierPath *)bezierPathWithRect:(CGRect)rect这个方法，设置好坐标 frame 就好了，就像我们创建 view 一样，好理解。 创建圆形或者椭圆形使用+ (UIBezierPath *)bezierPathWithOvalInRect:(CGRect)rect这个方法创建圆形或者椭圆形。传入的rect矩形参数绘制一个内切曲线，如果我们传入的rect是矩形就得到矩形的内切椭圆，如果传入的是 正方形得到的就是正方形的内切圆。 创建一段弧线使用+ (UIBezierPath *)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwis这个方法创建一段弧线，介绍一下这个方法中的参数： 弧线的参考系： 绘制二次贝塞尔曲线使用- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint这个方法绘制二次贝塞尔曲线。曲线段在当前点开始，在指定的点结束，一个控制点的切线定义。下图显示了两种曲线类型的相似，以及控制点和curve形状的关系: 绘制三次贝塞尔曲线 使用这个方法绘制三次贝塞尔曲线 这个方法绘制三次贝塞尔曲线。曲线段在当前点开始，在指定的点结束，两个控制点的切线定义。下图显示了两种曲线类型的相似，以及控制点和curve形状的关系: 画带圆角的矩形使用+ (instancetype)bezierPathWithRect:(CGRect)rect;这个方法绘制，这个方法和bezierPathWithRect:类似，绘制一个带内切圆的矩形。 指定矩形的某个角为圆角使用+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;这个方法绘制。参数的意思：rect 绘制矩形的 frame，corners指定使哪个角为圆角，圆角类型为： 用来指定需要设置的角。cornerRadii 圆角的半径 小结以上列举的这几种使用贝塞尔曲线绘制图形的方法就是我们在开发中经常能遇到的。"},{"title":"UICollectionView详解（二）：自定义UICollectionViewLayout","date":"2017-08-17T08:15:03.000Z","url":"/17/UICollectionView%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89UICollectionViewLayout/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"UICollectionViewLayout简介（1）基本方法在UICollectionViewLayout时，我们主要会重写它的以下几个方法 prepareLayout会在三个时机调用: 1、初始化layout的时候 2、刷新layout的时候 3、方法- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds 返回YES的时候 （2）UICollectionViewLayout与UICollectionViewFlowLayout​ 在此之前，我们先来简单的关注一下UICollectionViewFlowLayout和UICollectionViewLayout的关系：UICollectionViewFlowLayout是系统为我们封装的一个继承于UICollectionViewLayout的子类，系统已经写好了布局，所以如果我们在- (nullable NSArray&lt;__kindof UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect;方法中调用 NSArray *attributesArr = [super layoutAttributesForElementsInRect:rect];，可以得到系统为我们写好的布局，但是如果直接继承于UICollectionViewLayout，上述方法得不到任何布局，所以我们必须要重写- (nullable UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath;方法，在方法中写好布局并调用，这样才能为cell布局。 （3）UICollectionViewLayoutAttributes关于cell的布局，我们还需要着重看一个类：UICollectionViewLayoutAttributes，它就是我们上面一直所说的cell的布局类，cell所有的布局属性都是要写到该类中的，那它到底都有哪些属性呢： 改变了这些属性，并传递给layout，就可以改变cell的布局，所以归根到底，不管多复杂的布局，都是在改变这些属性。 自定义UICollectionViewLayout具体实现下面，我们就在具体的实例中看一下，如果使用自定义layout： 创建一个继承于UICollectionViewLayout的子类 大概思路就是：首先初始化layout的各种属性和变量，在 - (void)prepareLayout 中循环调用 -(UICollectionViewLayoutAttributes*)layoutAttributesForItemAtIndexPath：方法，为所有的cell添加布局，最后从 - (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect: 中将其返回即可。 本例中，调用layout的方法也很简单，就正常创建layout，并赋给collectionView就可以了： 下面是效果图： （注：在开发中，对于需要在外部的控制器中设置layout属性的，包括内边距、行间距、列间距、列数以及cell的初始大小等，可以为layout添加代理，使用代理方法返回）。 下面我们再看一个例子：首先，我们先创建一个继承于UICollectionViewFlowLayout的layout子类，layout类中不做任何实现，然后在控制器中赋值给collectionView，控制器中关于collectionView和数据源的设置和上例一样，然后运行程序，查看效果： ​ 我们发现，尽管layout没有做任何布局，但是collectionView任然可以显示，这就说明，UICollectionViewFlowLayout已经为我们做好了一个布局，就是我们现在看到的流水布局，所以，对于继承于UICollectionViewFlowLayout的 类，如果要改变cell的布局，只需要获取系统默认为cell写好的布局，然后再此基础上进行修改就可以了。那么怎样获取UICollectionViewFlowLayout为我们写好的布局呢，使用父类调用 -(NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect: 废话不多说，直接上代码： 效果图： 总结：基本上到这里，UICollectionVew的使用就结束了，如何能够将UICollectionVew使用的更好，关键就在于怎样更好的运用UICollectionViewLayout和UICollectionViewFlowLayout，这才是UICollectionVew的精髓所在。"},{"title":"UICollectionView详解（一）： 基本使用","date":"2017-08-06T12:13:35.000Z","url":"/06/UICollectionView%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"​ UICollectionView在目前的iOS开发中，使用非常广泛，它可以完成许多UITableView完成不了的复杂的布局，在使用上，两者也有着许多的相似之处，主要体现在布局的样式上，UITableView主要有两种布局：plain和group，而UICollectionView则可以根据我们的需要自定义各种各样复杂的布局，这也是下面我们就UICollectionView的使用进行一下详细的解析。 基本使用方法​ 与UITableView相似，在UICollectionView时，也要遵循数据源（UICollectionViewDataSource）与代理协议方法（UICollectionViewDelegate），也要注册cell，与UITableView不同的是，我们还需要为UICollectionView创建一个布局参数，也就是UICollectionViewFlowLayout，这也是UICollectionView的精髓所在，正是通过它，我们才实现了UICollectionView各式各样的布局，这我们在后面会一一讲述，有兴趣的同学也可以看一下苹果官方文档。 ​ 系统为我们提供了两个UICollectionView的布局类：UICollectionViewLayout和UICollectionViewFlowLayout，UICollectionViewLayout类是一个抽象类，我们在自定义布局的时候可以继承此类，并在此基础上设置布局信息，UICollectionViewFlowLayout继承于UICollectionViewLayout，是系统为我们写好的布局类，该类为我们提供了一个简单的布局样式，假如我们只需要一个特别简单的网格布局或者流水布局，可以直接使用它。 创建UICollectionView的基本代码如下： 初始化 实现协议方法 最终的效果图如下： ​ 上面我们提到了，UICollectionViewFlowLayout是系统为我们提供的一个简单的流水布局，那么我们在直接使用它做简单的布局时，可以直接设置它的一个属性，来达到我们布局的目的，这样就可以省略掉一些UICollectionView协议方法的实现。我们来看一下UICollectionViewFlowLayout都有哪些属性可以设置： ​ 和上面我们实现的UICollectionView中的一些协议方法的名字非常相似，根据名字应该可以一一对应。那么，使用UICollectionViewFlowLayout的属性设置布局的效果如果呢，我们来看： 代码实现 效果图： 事实证明，两种方法在实现的效果上并没有任何区别。 总结​ 关于UICollectionView的基本使用大概就是这些内容，但是这些只适用于一些简单的网格或流水布局，如果遇到比较复杂的布局，比如瀑布流等，就需要自定义UICollectionViewLayout来布局了。在下一篇文章中，我们会详细介绍如何使用自定义UICollectionViewLayout来编写复杂布局。"},{"title":"iOS核心动画(CoreAnimation)","date":"2017-07-27T13:26:29.000Z","url":"/27/iOS%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB-CoreAnimation/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"CoreAnimation是iOS中的核心动画框架，是iOS开发中专门用来处理动画的API，在开发中使用CoreAnimation可以做出很多很炫酷的动画。下面，就对CoreAnimation的使用做出详细的解析。 UIView动画​ 在说CoreAnimation之前，可以先简单的介绍一下UIView动画，UIView动画用起来很简单，实现的动画也是非常简单。​ 在开发中，我们也会经常调用到，主要有两种调用方式： block代码块调用 ​ 常用的还有delay参数和completion的回调方法，completion中是动画完成后的回调，可以在做一些动画完成后要执行的任务，delay是动画延迟执行的时间。 [begin commit]代码段调用 ​ 这种方式需要将执行的动画内容放到beginAnimations和commitAnimations中间，包括一些要设置的属性，如：Duration、Delay、StartDate、Curve、RepeatCount等等，还可以通过设置setAnimationDelegate代理，来监听动画的开始和结束。 核心动画（CoreAnimation）​ CoreAnimation的动画实现是在layer层，每一个UIView的对象在创建的时候都会生成一个layer层，我们平时看到的view上展示的元素都是layer层绘制和显示的，通过改变layer的属性，就可以实现复杂的动画了。其实，UIView动画也可以看做是CoreAnimation的封装，不过，值得注意的是：UIView动画在执行完成后，view本身是发生改变的，CoreAnimation在执行完成后，view本身是没有发生改变的，只是看起来变了而已。​ CoreAnimation的基类为CAAnimation，实现了CAMediaTiming协议，以用来控制动画的时间、速度和时间曲线等，CoreAnimation不能直接使用，需要使用它的子类：CAAnimationGroup、CAPropertyAnimation和CATransition，CAPropertyAnimation一般也不会直接时候，它又有两个子类：CABasicAnimation、CAKeyframeAnimation。 综上所述，可以使用的动画的类包括： CABasicAnimation： 基础动画CAKeyframeAnimation： 关键帧动画CATransition： 转场动画CAAnimationGroup： 动画组 CABasicAnimation（基础动画） 其中，keyPath对应的是想要改变的layer的属性，支持动画的属性主要包括以下这些： &#x2F;&#x2F;CATransform3D Key Paths :rotation.xrotation.yrotation.zrotation 旋转 scale.xscale.yscale.zscale 缩放 translation.xtranslation.ytranslation.ztranslation 平移 经常用到的还有以下属性： fillMode、removedOnCompletion，他们两个同时使用， basicAnimation.fillMode &#x3D; kCAFillModeForwards;basicAnimation.removedOnCompletion &#x3D; NO; 动画执行完成后，视图不会再回到原来的位置。 timingFunction ：动画执行时的效果： basicAnimation.timingFunction &#x3D; [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]; 同时，要想移除动画，系统提供了两个方法： CAKeyframeAnimation（关键帧动画）关键帧动画可以为动画的执行过程设置若干个中间点，中间点前后动画的属性可以设置多个不同的值，动画可以沿着设置的中间点顺序执行。 关键帧动画有几个非常重要的属性： values：关键帧数组对象，里面每一个元素即为一个关键帧，动画会在对应的时间段内，依次执行数组中每一个关键帧的动画。path：动画路径对象，可以指定一个路径，在执行动画时路径会沿着路径移动，Path在动画中只会影响视图的Position。keyTimes：设置关键帧对应的时间点，范围：0-1。如果没有设置该属性，则每一帧的时间平分。 利用path属性，我们可以使用关键帧动画来实现画圆圈的动画： CATransition（转场动画） 转场动画两个重要的属性： type：转场动画的种类，公有api主要有四个： 渐变 kCATransitionFade 、覆盖 kCATransitionMoveIn 推出 kCATransitionPush 、揭开kCATransitionReveal 还有一些私有api：”cube”、”suckEffect”、”oglFlip”、 “rippleEffect”、”pageCurl”、”pageUnCurl” 动画的方向，有以下几种： kCATransitionFromRight 从右边、kCATransitionFromLeft 从左边 kCATransitionFromTop 从顶部、kCATransitionFromBottom 从底部 CAAnimationGroup（动画组）CAAnimationGroup顾名思义就是一组动画，动画组中可以添加多个动画，动画组中的动画可以并发运行。我们平时见到的一些炫酷的动画，都是依赖动画组完成的。CAAnimationGroup最重要的属性： animations： 数组类型，用来接收动画组中要添加的动画 总结：平时大家看到的动画，无论多么复杂，都是由一个个简单的动画组合而成的，在使用的时候，我们要进行合适的组合，控制好动画的属性，就能达到我们满意的效果。"},{"title":"Runloop的知识点","date":"2017-07-15T12:12:28.000Z","url":"/15/Runloop%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":[["Runloop","/tags/Runloop/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"1、什么是RunLoopRunLoop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行。使用run loop的目的是让你的线程在有工作的时候忙于工作，没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。 2、RunLoop和线程●RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。 ●每条线程都有唯一一个与之对应的RunLoop对象。 ●我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。 ●RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。 ●主线程的RunLoop对象系统自动帮助我们创建好了，而子线程的RunLoop对象需要我们主动创建。 默认情况下主线程的RunLoop原理 其中UIApplicationMain函数内部帮我们开启了主线程的RunLoop，UIApplicationMain内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码： 从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。 下图是苹果官方给出的 RunLoop 模型图。 从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。 3、RunLoop 相关类下面我们来了解一下Core Foundation框架下关于RunLoop的5个类，只有弄懂这几个类的含义，我们才能深入了解RunLoop运行机制。 ●CFRunLoopRef：代表RunLoop的对象 ●CFRunLoopModeRef：RunLoop的运行模式 ●CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源&#x2F;事件源 ●CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源 ●CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变 下边详细讲解下几种类的具体含义和关系。 ●每次 RunLoop 启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作当前运行模式（CurrentMode）。 ●如果需要切换运行模式（CFRunLoopModeRef），只能退出当前 Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。 ●这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。 3.1 CFRunLoopRef 类CFRunLoopRef 是 Core Foundation 框架下 RunLoop 对象类。我们可通过以下方式来获取 RunLoop 对象： 3.2 CFRunLoopModeRef系统默认定义了多种运行模式（CFRunLoopModeRef） ●kCFRunLoopDefaultMode：App的默认运行模式，通常主线程是在这个运行模式下运行 ●UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响） ●UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用 ●GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到 ●kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式（后边会用到） 其中kCFRunLoopDefaultMode、UITrackingRunLoopMode、kCFRunLoopCommonModes是我们开发中需要用到的模式. 3.3 CFRunLoopTimerRefCFRunLoopTimerRef是定时源，理解为基于时间的触发器 下面我们来演示下 CFRunLoopModeRef 和 CFRunLoopTimerRef 结合的使用用法 然后运行，这时候我们发现如果我们不对模拟器进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。但是当我们拖动ScrollView滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们松开鼠标的时候，NSTimer就又开始正常工作了。 原因： ●当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。 ●而当我们拖动Scroll View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。 ●但当我们松开鼠标的时候，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。 3.4 CFRunLoopSourceRefCFRunLoopSourceRef是事件源CFRunLoopSourceRef有两种分类方法。 第一种按照官方文档来分类： Port-Based Sources（基于端口） Custom Input Sources（自定义） Cocoa Perform Selector Sources 第二种按照函数调用栈来分类： Source0 ：非基于Port Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件 这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。 下边我们举个例子大致来了解一下函数调用栈和Source。 1.在我们的项目中的Main.storyboard中添加一个Button按钮，并添加点击动作。 2.然后在点击动作的代码中加入一句输出语句，并打上断点，如下图所示： 3.然后运行程序，并点击按钮。 4.然后在项目中单击下下图红色部分。 5.可以看到如下图所示就是点击事件产生的函数调用栈。 所以点击事件是这样来的： 1.首先程序启动，调用16行的main函数，main函数调用15行UIApplicationMain函数，然后一直往上调用函数，最终调用到0行的BtnClick函数，即点击函数。 2.同时我们可以看到11行中有Sources0，也就是说我们点击事件是属于Sources0函数的，点击事件就是在Sources0中处理的。 3.而至于Sources1，则是用来接收、分发系统事件，然后再分发到Sources0中处理的。 3.5 CFRunLoopObserverRefCFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变 CFRunLoopObserverRef可以监听的状态改变有以下几种： 下边我们通过代码来监听下RunLoop中的状态改变 4、RunLoop原理好了，五个类都讲解完了，我们就可以来理解RunLoop的运行逻辑了。 在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。 具体的顺序如下： 1.通知观察者RunLoop已经启动 2.通知观察者即将要开始的定时器 3.通知观察者任何即将启动的非基于端口的源 4.启动任何准备好的非基于端口的源 5.如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9 6.通知观察者线程进入休眠状态 7.将线程置于休眠知道任一下面的事件发生： ​ ○某一事件到达基于端口的源 ​ ○定时器启动 ​ ○RunLoop设置的时间已经超时 ​ ○RunLoop被显示唤醒 8.通知观察者线程将被唤醒 9.处理未处理的事件 ​ ○如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2 ​ ○如果输入源启动，传递相应的消息 ​ ○如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2 10.通知观察者RunLoop结束。 5、RunLoop实战应用5.1NSTimer的使用 5.2后台常驻线程我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。 "},{"title":"iOS之蓝牙开发技术","date":"2017-07-10T13:07:42.000Z","url":"/10/iOS%E4%B9%8B%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/","tags":[["智能设备","/tags/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"随说 : 本文结合自己做的这个项目来整理开发思路,这一篇着重 &lt;蓝牙&gt; 交互模块前期准备 : 硬件商家提供的电路板 硬件商家提供的电路板通讯协议 看懂通讯协议 我模拟了一份通讯协议的资料,凑合着看吧当然,实际情况的指令会多的多 序号 : 指令的序号(没啥意义)指令名称 : 就是给指令定义一个名字,一般可以作为储存 本地的Key指令 : 实际操作电脑版接收的数据验证指令 : 根据一个验证算法得出的数据.备注 : 告诉你这个是干嘛的. 连接设备将电路板通电,然后它就处于可被检测状态.作为App来说,首先需要检测iphone是否处于蓝牙开启状态 1、创建Central管理器 2、检测蓝牙状态 确保蓝牙打开,才能扫描设备 3、扫描设备 4、连接蓝牙设备 5、连接成功 6、发现外设 7、发现service的特征 8、传输数据 characteristic 有几种属性Read : 只读Write Without Response : 写数据不接收回执Write : 只写Notify : 通知(不需要对方回复)Indicate : 通知(需要回复) 这个项目中,只用到了write 与 notify 蓝牙硬件版本升级 最近给产品做了DFU升级其实DFU升级是app端和驱动这边共同完成的，这个协议是自己定义的，所以每个公司的升级都不一样，但从根本上看都是一样的，就是把升级包发给固件，然后进行升级，下面就来简单的说下我们这边的步骤。 1、发送升级指令就是给固件发送一个指令，告诉固件，进入升级模式，当然在这之前有的公司会先发送一个查询固件的版本，然后对比当前版本和最新版，看是否需要升级，如果需要，再发送升级指令。这时，固件一般会断开蓝牙，切换成升级模式。 2、发送升级包当固件切换完模式以后，需要重新连接蓝牙;这一步就是将升级包发送给固件了，由于蓝牙每次发送数据大小的限制，升级包一般都要分多次发送，每次发送一部分。 3、校验重启当整个升级包都发送给固件以后，固件就会进行升级，升级完成之后固件就可以重启，把模式切换回正常使用模式了。对此，整个升级就完成了，还是前面说的，升级是和驱动这边共同完成的，双方定义如何升级，但总的都是获取升级包，发送给固件，固件进行升级这样。 注意：有的公司会把升级包放到服务器，也有的公司会在更新App时将固件升级包放到App里，毕竟固件升级的频率还是很低的,能不升级则尽量不要升级。 项目示例地址"},{"title":"app配置智能硬件解决方案","date":"2017-07-01T09:41:08.000Z","url":"/01/app%E9%85%8D%E7%BD%AE%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","tags":[["智能设备","/tags/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"做智能家居有一段日子了,近段时间公司项目紧, 也有好些时间没有写一些技术文章总结.趁着周末时间,整理一下自己的思路,整理一下知识点.其实现在的所谓各种各样的智能产品, 什么智能厨房,智能破壁机,智能空调等等.因为受到各种传感器等的技术限制,我认为这些都不是真正名义上的智能.它们并没有什么”思想”,只是单纯地将硬件接入wifi模块,连接到路由器,再通过路由器连接互联网进行信息交互. so : 现在的智能只是令原来不能上网的各种各样的硬件,拥有了联通互联网的功能. app配置智能硬件方式1、最开始的红外线交互2、BLE交互(蓝牙低能耗技术),现在基本用的是蓝牙4.03、nfc交互（近距离无线通讯技术）苹果支付你知道了吧, 将你手机放过去感应一下,滴滴滴..就付款了,就是利用了这个技术, 信息就是通过nfc交互的 4、AP方式在各式各样的硬件上植入软ap,再利用手机连接软ap配置路由的ssid和密码, 然后智能硬件就可以自行连接了路由器了,也就实现了上网的功能.硬件中的软ap连接路由器后,通过我们自己的服务器处理,手机通过4G网络也能够控制智能硬件了。 5、Smart Config利用了UDP协议与,智能硬件wifi模块中monitor模式, 其实和上面第四部的操作大致雷同, 不一样的地方在于,手机端填写好ssid和密码之后,不断发送udp广播包,智能硬件通过接收这些udp传输的包内数据知道ssid和密码,然后自动连接上路由器 6、声波配置这种方式现在应用挺广的支付宝等都有应用，其主要的原理就是手机放出经过编码加密的声音，智能硬件通过麦克风录音，解码解密，然后配置成功。 接着就和上述基本类似一个简单的配置可以通过很多方式，最终的目的不约而同，就是为了使用户更方便地体验产品。加上APP上的人性化设置，让用户体验十分舒服。相比而言，后面两中方式更加值得拥有，也就是所谓的一键配置功能。 我开发是基于第五点, 以我们公司来说,wifi模块是由别的厂家提供, 同时厂家也给出一份wifi模块的通讯协议供我们参考。正如第五点所说功能连接所说，我这一边需要做的工作主要有 注册服务。(也就是将路由ssid与密码通过wifi模块提供的协议注册一个服务) 检索服务, 写一个检索服务的模块,来获取我需要的信息 检索到服务之后,通过苹果提供的代理方法,获取服务的基本信息(例如IP,例如Mac地址) 连接之后,就可以通过wifi模块提供的协议,去控制智能硬件,从而改变硬件的一些状态 "},{"title":"UITableView代理方法详解","date":"2017-06-21T04:48:40.000Z","url":"/21/UITableView%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"UITableView代理方法详解 一、UITableViewDataSource（数据源代理）1、必须实现的回调方法 2、可选实现的方法 二、UITableViewDelegate（tableView代理）"},{"title":"UITableViewCell使用详解","date":"2017-06-17T14:00:25.000Z","url":"/17/UITableViewCell%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"iOS中UITableViewCell使用详解 "},{"title":"UITableView的使用","date":"2017-06-17T13:16:38.000Z","url":"/17/UITableView%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"iOS中UITableView使用总结 一、初始化方法- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style; 这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下： 二、常用属性 三、常用方法详解 四、tableView操作刷新块的应用在介绍动画块之前，我们先看几个函数： 了解了上面几个函数，我们来看什么是操作刷新块： 当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，然而数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。 IOS为我们提供了下面两个函数解决这个问题： 我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下： 注意：不要在这个块中调用reloadData这个方法，它会使动画失效。 五、tableView的编辑操作 六、选中cell的相关操作 七、tableView附件的相关方法"},{"title":"UIScrollerView的使用","date":"2017-06-14T13:52:20.000Z","url":"/14/UIScrollerView%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"UIScrollerView常见属性 CGPoint contentOffset这个属性用来表示UIScrollerView滚动的位置（其实就是内容左上角与ScrollerView左上角的间距值） CGSize contentSize这个属性用来表示UIScrollerView内容尺寸，滚动范围（能滚多远） UIEdgeInsets contentInset这个属性能够在UIScrollerView的四周增加额外的滚动区域，一般用来避免scrollerView的内容被其他控件挡住 UIScrollerView无法滚动的原因 没有设置contentSize scrollEnabled &#x3D; NO 没有收到触摸事件：ueserInteractionEnabled &#x3D; NO UIScrollerView代理方法 ScrollerView滑动的代理回调 ScrollerView缩放的代理回调必须设置scrollerView的缩放比例scrollerView.maximumZoomScale = 2.0;scrollerView.minimumZoomScale = 0.2; ScrollerView缩放的代理回调 UIScrollerView分页（电商与新闻常用） "},{"title":"WKWebView的使用","date":"2017-06-10T12:44:22.000Z","url":"/10/WKWebView%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"WKWebView 是苹果在iOS 8中引入的新组件，目的是提供一个现代的支持最新 Webkit 功能的网页浏览控件，摆脱过去 UIWebView的老、旧、笨，特别是内存占用量巨大的问题。它使用与 Safari 中一样的Nitro JavaScript引擎，大大提高了页面 js 执行速度。 一、WKWebView涉及的一些类 WKWebView：网页的渲染与展示 WKWebViewConfiguration：为添加WKWebView配置信息 WKUserScript：用于进行JavaScript注入 WKScriptMessageHandler：这个协议类专门用来处理监听JavaScript方法从而调用原生OC方法，和WKUserContentController搭配使用。 二、WKWebView涉及的代理方法 WKNavigationDelegate ：主要处理一些跳转、加载处理操作 WKUIDelegate ：主要处理JS脚本，确认框，警告框等 三、网页内容加载进度条和title的实现 四、JS和OC的交互 这个实现主要是依靠WKScriptMessageHandler协议类 和 WKUserContentController两个类：WKUserContentController 对象负责注册JS方法，设置处理接收JS方法的代理，代理遵守WKScriptMessageHandler，实现捕捉到JS消息的回调方法，详情可以看第一步中对这两个类的介绍。 JS调用OC OC调用JS "},{"title":"UIWebView的使用","date":"2017-06-03T14:04:22.000Z","url":"/03/UIWebView%E7%9A%84%E4%BD%BF%E7%94%A8/","tags":[["UI控件","/tags/UI%E6%8E%A7%E4%BB%B6/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":"UIWebView的使用 一、初始化与三种加载方式UIWebView继承与UIView，因此，其初始化方法和一般的view一样，通过alloc和init进行初始化，其加载数据的方式有三种： 第一种： 这是加载网页最常用的一种方式，通过一个网页URL来进行加载，这个URL可以是远程的也可以是本地的，例如我加载百度的主页： 第二种： 第三种： 二、一些常用的属性和变量 三、iOS7中的一些新特性 四、webView协议中的方法"},{"title":"NSDictionary实现原理","date":"2017-05-29T07:50:07.000Z","url":"/29/NSDictionary%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","tags":[["底层原理","/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"]],"categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":" NSDictionary介绍 NSDictionary（字典）是使用 hash表来实现key和value之间的映射和存储的， hash函数设计的好坏影响着数据的查找访问效率。数据在hash表中分布的越均匀，其访问效率越高。而在Objective-C中，通常都是利用NSString 来作为键值，其内部使用的hash函数也是通过使用 NSString对象作为键值来保证数据的各个节点在hash表中均匀分布。 NSDictionary内部结构NSDictionary使用NSMapTable实现，NSMapTable同样是一个key－value的容器。 上述结构体描述了遍历一个NSMapTable时的一个指针对象，其中包含table对象自身的指针，计数值，和节点指针。 上述结构体中存放的是几个函数指针，用于计算key的hash值，判断key是否相等，retain，release操作。 上述存放的三个函数指针，定义在对NSMapTable插入一对key－value时，对value对象的操作。 可以看出来NSMapTable是一个哈希＋链表的数据结构，因此在NSMapTable中插入或者删除一对对象时，寻找的时间是O（1）＋O（m），m最坏时可能为n。 O（1）：为对key进行hash得到bucket的位置 O（m）：遍历该bucket后面冲突的value，通过链表连接起来。 因此NSDictionary中的Key-Value遍历时是无序的，至如按照什么样的顺序，跟hash函数相关。NSMapTable使用NSObject的哈希函数。 上述是NSObject的哈希值的计算方式，简单通过移位实现。右移4位，左边补0。因为对象大多存于堆中，地址相差4位应该很正常。 NSDictionary使用NSDictionary的Key值NSDictionary中最常用的一个方法原型： 从这个方法中可以知道，要作为Key值，必须遵循NSCopying协议。也就是说在NSDictionary内部，会对aKey对象Copy一份新的。而anObject 对象在其内部是作为强引用（retain或strong)。所以在MRC下，向该方法发送消息之后，我们会向anObject发送release消息进行释放。 既然知道了作为key值，必须遵循NSCopying协议，说明除了NSString对象之外，我们还可以使用其他类型对象来作为NSDictionary的 key值。不过这还不够，作为key值，该类型还必须继承于NSObject并且要重载一下两个方法： 其中，hash 方法是用来计算该对象的 hash 值，最终的 hash 值决定了该对象在 hash 表中存储的位置。所以同样，如果想重写该方法，我们尽量设计一个能让数据分布均匀的 hash 函数。 所以如果对象key的hash值相同，那在hash表里面的对应的value值是相同的(value值被更新了) isEqual方法是为了通过hash值来找到对象在hash表中的位置。 KeyObject.h文件： KeyObject.m文件 测试 打印结果：2017-05-29 15:40:06.429379+0800 testD[6350:1441941] key1—&gt;key1value2017-05-29 15:40:06.454114+0800 testD[6350:1441941] key2—&gt;key2value2017-05-29 15:40:06.454137+0800 testD[6350:1441941] key3—&gt;key3value2017-05-29 15:40:06.454634+0800 testD[6350:1441941] allKeys—&gt;(“&lt;KeyObject: 0x100403440&gt;”,“&lt;KeyObject: 0x100406b10&gt;”)2017-05-29 15:40:06.454779+0800 testD[6350:1441941] allValues—&gt;(key2value,key3value)Program ended with exit code: 0 从打印结果来看，key1和key2对象的hash值是一样的，所以他们value是相等的，key1的value被key2更新了。 NSDictionary的KVC实现 setValue和setObject的区别 setObject: ForKey:是NSMutableDictionary特有的；setValue: ForKey:是KVC的主要方法。 (1) setValue: ForKey:的value是可以为nil的（但是当value为nil的时候，会自动调用removeObject：forKey方法）；setObject: ForKey:的value则不可以为nil。(2) setValue: ForKey:的key必须是不为nil的字符串类型； setObject: ForKey:的key可以是不为nil的所有继承NSCopying的类型。"},{"title":"NSString的使用","date":"2017-05-25T12:04:22.000Z","url":"/25/NSString%E7%9A%84%E4%BD%BF%E7%94%A8/","categories":[["iOS知识点","/categories/iOS%E7%9F%A5%E8%AF%86%E7%82%B9/"]],"content":" 项目中用到NSString的几个方法，发现自己对NSString的方法认识的还不系统不完全，利用闲暇时间整理下一些基础NSString方法 "},{"title":"搭建自己个人博客","date":"2017-05-22T12:38:24.000Z","url":"/22/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","categories":[["Hexo","/categories/Hexo/"]],"content":"为什么要有自己的个人网站呢？我觉得现在身处于互联网时代，有自己的个人网站其实就和互联网上的一张名片差不多了，在这里可以不断的记录自己的生活，总结自己的知识，人生思考什么的，以后介绍自己直接把网站扔给对方。一来是可以装下逼，二来是可以让对方更好的了解自己。 1、安装node.js安装先安装包管理器brew，参考：有以上前提后，输入： 验证 更新 2、安装git如果安装上面的步骤安装了node.js，那么安装git就只需要在终端输入下面一句就好了 验证一下 3、安装hexo安装Hexo的非常简单，只要一条命令，前提是安装好Node.js与Git 初始化，随便创建一个文件夹，名字随便取，***cd***创建的文件夹里面，执行下面命令： 本地启动 访问本地链接： 4、安装主题（Next为例）更多主题查看官网 复制主题 启用主题打开根目录下的_config.yml文件，找到 theme 字段，并将其值更改为 next 再执行 hexo clean 和 hexo s 就可以在本地预览效果了 5、注册GitHub并创建仓库仓库名称格式要求：用户名.github.io 比如：GitHub的用户名称为 lisi, 则创建的仓库名为：lisi.github.io 配置SSH 生成SSH Key 登录Github，右上角 头像 -&gt; Settings —&gt; SSH nd GPG keys —&gt; New SSH key 。把id_rsa.pub的内容复制粘贴到key中，填好title并点击 Add SSH key 验证一下是否成功 之后还需要设置username和email,为了记录每次提交的记录 6、部署到GitHub中去安装Git部署插件 打开_config.yml文件，在最底部修改部署配置，注意严格的空格 保存后在终端执行以下命令 部署完成后可在浏览器输入 yourname.github.io 这样就能看到自己一个属于自己的博客了。"},{"title":"Hexo使用攻略-添加分类及标签","date":"2017-05-21T12:26:01.000Z","url":"/21/Hexo%E4%BD%BF%E7%94%A8%E6%94%BB%E7%95%A5-%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/","categories":[["Hexo","/categories/Hexo/"]],"content":"本教程针对的是Mac环境下，kratos-rebirth主题的文章分类和标签设置，其他主题也应该是类似的。添加成功后会在侧边栏或导航栏生成“分类”和“标签”这两个选项，看下图： 1、创建“分类”选项1.1 生成“分类”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 成功后会提示： 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 添加type: &quot;categories&quot;到内容中，添加后是这样的： 保存并关闭文件。 1.2 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: iOS知识点表示添加这篇文章到“iOS知识点”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- iOS知识点”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- iOS知识点”下的 “-xxx ”分类）。 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 2、创建“标签”选项2.1 生成“标签”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 成功后会提示： 根据上面的路径，找到index.md这个文件，打开后默认内容是这样的： 添加type: &quot;tags&quot;到内容中，添加后是这样的： 保存并关闭文件。 2.2 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- iOS 就是这篇文章的标签了 至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。 细心的朋友可能已经发现，这两个的设置几乎一模一样！是的，没错，思路都是一样的。所以我们可以打开scaffolds&#x2F;post.md文件，在tages:上面加入categories:,保存后，之后执行hexo new 文章名命令生成的文件，页面里就有categories:项了。 scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。 教程结束，赶紧去设置吧"}]